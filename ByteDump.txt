******************************* Segment: Default *******************************
[Header]
0801: 0c 08     -         .word bend
0803: 0d 00     -         .byte $0d, $00				//;line number
0805: 9e        -         .byte $9E					//;SYS
0806: 20        -         .byte $20					//;space
0807: 32 30 36 34                                      -         .byte $32,$30,$36,$34		//;start 2064
080b: 00        -         .byte $00					//;end of line
080c: 00 00     - bend:   .byte $00, $00				//;end of basic program

[Main]
0810: 20 0a 09  - setup:  jsr COPY_CHAR_ROM_TO_RAM
0813: 20 75 14  -         jsr set_bricks
0816: a9 0f     -         lda	#color
0818: a0 00     -         ldy #0
081a: 99 00 d8  - fill:   sta COLOR_RAM,y
081d: 99 00 d9  -         sta COLOR_RAM + 256,y
0820: 99 00 da  -         sta COLOR_RAM + 512,y
0823: 99 00 db  -         sta COLOR_RAM + 768,y
0826: c8        -         iny
0827: d0 f1     -         bne fill
0829: a9 00     -         lda #BLACK
082b: 8d 21 d0  -         sta BACKGROUND
082e: 78        - interrupt:sei							//set interrupt
082f: a9 7f     -         lda #$7f
0831: 8d 0d dc  -         sta CIA_ICR
0834: 8d 0d dd  -         sta CIA2_ICR
0837: ad 0d dc  -         lda CIA_ICR
083a: ad 0d dd  -         lda CIA2_ICR
083d: ad 1a d0  -         lda INTERRUPT_MASK_REGISTER	
0840: 09 01     -         ora #$01
0842: 8d 1a d0  -         sta INTERRUPT_MASK_REGISTER
0845: ad 11 d0  -         lda CONTROL_REGISTER1
0848: 29 7f     -         and #$7f
084a: 8d 11 d0  -         sta CONTROL_REGISTER1
084d: a9 32     -         lda #startRaster
084f: 8d 12 d0  -         sta RASTER_COUNTER
0852: a9 40     -         lda #<address
0854: 8d 14 03  -         sta IRQVEC
0857: a9 14     -         lda #>address
0859: 8d 15 03  -         sta	IRQVEC+1
085c: 58        -         cli
085d: d8        - begin:  cld
085e: a9 02     - init:   lda #B
0860: 8d d9 13  -         sta bias
0863: a9 00     -         lda #00
0865: 8d da 13  -         sta bias_counter
0868: a9 00     -         lda #<addr
086a: 8d b6 13  -         sta X
086d: a9 04     -         lda #>addr
086f: 8d b7 13  -         sta X+1
0872: a9 00     -         lda #<addr
0874: 85 71     -         sta X
0876: a9 c0     -         lda #>addr
0878: 85 72     -         sta X+1
087a: a9 00     -         lda #<addr
087c: 85 5c     -         sta X
087e: a9 c4     -         lda #>addr
0880: 85 5d     -         sta X+1
0882: a9 00     -         lda #<addr
0884: 85 5e     -         sta X
0886: a9 c5     -         lda #>addr
0888: 85 5f     -         sta X+1
088a: a9 00     -         lda #00
088c: 8d dd 13  -         sta DE_counter
088f: 8d de 13  -         sta REM_DE_counter
0892: 20 bb 09  -         jsr MAZE_FILL
0895: 20 32 0a  -         jsr ROOMS
0898: 20 fa 10  -         jsr SET_START
089b: 20 f3 12  -         jsr MAZE
089e: 20 23 11  -         jsr CONNECT_ROOMS
08a1: 20 17 0f  -         jsr CONNECT_DEAD_ENDS
08a4: a5 c5     - end,key:lda LSTX		//get character in A
08a6: c9 40     -         cmp #64			//no key
08a8: f0 fa     -         beq key
08aa: 4c 5e 08  -         jmp init
08ad: 60        -         rts

[Imports]
08ae: c6 48     - imports,SPLICE:dec VAR_B								//array length - 1, last index
08b0: a4 47     -         ldy VAR_A								//index
08b2: c4 48     - loop:   cpy VAR_B								//stop if index
08b4: 10 35     -         bpl out 								//equal or greater than last index
08b6: a2 00     -         ldx #0									//number of properties (data_size), start from 0
08b8: c8        - each:   iny		
08b9: 84 40     -         sty TEMPY
08bb: a5 49     -         lda	VAR_C 								//data size
08bd: 20 ec 08  -         jsr MUL_Y_A
08c0: 84 02     -         sty ZP0
08c2: 8a        -         txa
08c3: 18        -         clc
08c4: 65 02     -         adc ZP0
08c6: a8        -         tay
08c7: b1 43     -         lda (BV1),y
08c9: 85 41     -         sta TEMPA1
08cb: a4 40     -         ldy TEMPY
08cd: 88        -         dey
08ce: 84 40     -         sty TEMPY
08d0: a5 49     -         lda	VAR_C 								//data size
08d2: 20 ec 08  -         jsr MUL_Y_A
08d5: 84 02     -         sty ZP0
08d7: 8a        -         txa
08d8: 18        -         clc
08d9: 65 02     -         adc ZP0
08db: a8        -         tay
08dc: a5 41     -         lda TEMPA1
08de: 91 43     -         sta (BV1),y
08e0: a4 40     -         ldy TEMPY
08e2: e8        -         inx
08e3: e4 49     -         cpx VAR_C								//all props? less than VAR_C ?
08e5: 90 d1     -         bcc each
08e7: c8        -         iny
08e8: 4c b2 08  -         jmp loop
08eb: 60        - out:    rts
08ec: c0 00     - MUL_Y_A,multiply:cpy #00
08ee: f0 18     -         beq end
08f0: 88        -         dey
08f1: 8c fe 08  -         sty mod+1
08f4: 4a        -         lsr
08f5: 85 02     -         sta ZP0
08f7: a9 00     -         lda #00
08f9: a0 08     -         ldy #$08
08fb: 90 02     - loop:   bcc skip
08fd: 69 00     - mod:    adc #0
08ff: 6a        - skip:   ror
0900: 66 02     -         ror ZP0
0902: 88        -         dey
0903: d0 f6     -         bne loop
0905: a4 02     -         ldy ZP0
0907: 60        -         rts
0908: 98        - end:    tya
0909: 60        -         rts
090a: 78        - COPY_CHAR_ROM_TO_RAM:sei
090b: a5 01     -         lda $01			//make ROM visible
090d: 29 fb     -         and #$FB
090f: 85 01     -         sta $01 
0911: a9 00     -         lda #00
0913: 85 5f     -         sta $5f			//block start
0915: 85 5a     -         sta $5a			//block end
0917: 85 58     -         sta $58			//destination end
0919: a0 d0     -         ldy #$d0
091b: 84 60     -         sty $60			//block start
091d: a0 e0     -         ldy #$e0		
091f: 84 5b     -         sty $5b			//block end
0921: a0 40     - ram:    ldy #$40
0923: 84 59     -         sty $59			//destination end
0925: 20 bf a3  -         jsr MOVE_BYTES
0928: a5 01     -         lda $01			//hide rom
092a: 09 04     -         ora #$04
092c: 85 01     -         sta $01
092e: 58        -         cli
092f: ad 18 d0  -         lda VMCSB
0932: 29 f0     -         and #%11110000
0934: 09 0c     -         ora #%00001100	//$3000
0936: 8d 18 d0  -         sta VMCSB
0939: 60        -         rts

[SYSTEM_data]
093a: e6 fd     - SYS_data,rnd_XY:inc ZP3
093c: d0 02     -         bne skip1
093e: e6 fe     -         inc ZP4
0940: a5 fd     - skip1:  lda ZP3
0942: 38        -         sec
0943: e5 fb     -         sbc ZP1
0945: 85 fd     -         sta ZP3
0947: a5 fe     -         lda ZP4
0949: e5 fc     -         sbc ZP2
094b: 85 fe     -         sta ZP4			
094d: a4 fd     - toFloat:ldy ZP3
094f: a5 fe     -         lda ZP4
0951: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
0954: a2 a6     -         ldx #<flt
0956: a0 09     -         ldy #>flt
0958: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
095b: a9 00     -         lda #$00					//RND(0)
095d: 20 9a e0  -         jsr RND						//$E09A
0960: a9 a6     -         lda #<flt
0962: a0 09     -         ldy #>flt
0964: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
0967: 20 cc bc  -         jsr FAINT					//to integer
096a: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
096d: a5 65     -         lda $65						//FAC mantissa lo
096f: 18        -         clc
0970: 65 fb     -         adc ZP1						//add number to start	
0972: 85 14     -         sta WINT
0974: a5 64     -         lda $64						//FAC mantissa hi
0976: 65 fc     -         adc ZP2
0978: 85 15     -         sta WINT+1
097a: 60        - over:   rts			
097b: e6 fd     - rnd_X:  inc ZP3
097d: d0 02     -         bne toFloat
097f: e6 fe     -         inc ZP4	
0981: a4 fd     - toFloat:ldy ZP3
0983: a5 fe     -         lda ZP4
0985: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
0988: a2 a6     -         ldx #<flt
098a: a0 09     -         ldy #>flt
098c: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
098f: a9 00     -         lda #$00					//get actual RND(0)
0991: 20 9a e0  -         jsr RND						//$E09A
0994: a9 a6     -         lda #<flt
0996: a0 09     -         ldy #>flt
0998: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
099b: 20 cc bc  -         jsr FAINT					//to integer
099e: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
09a1: a5 65     -         lda $65						//FAC mantissa lo
09a3: 85 14     -         sta WINT					
09a5: 60        -         rts			

[Data RND]
09a6: 00 00 00 00 00                                   - dataRND,flt:.byte 0,0,0,0,0

[Grid_Constants]
09ab: 00 ff     - Grid_Constants,BASIC_DIRS,UP:.byte 	0, -1
09ad: 00 01     - DOWN:   .byte 	0, 1
09af: ff 00     - LEFT:   .byte	-1, 0
09b1: 01 00     - RIGHT:  .byte 	1,0
09b3: ff ff     - PROX_TEMPLATE:.byte 	-1, -1
09b5: 01 01     -         .byte 	1, 1
09b7: ff ff     -         .byte 	-1, -1
09b9: 01 01     -         .byte 	1, 1
09bb: ad b6 13  - MAZE_FILL:lda X
09be: 85 fb     -         sta Y
09c0: ad b7 13  -         lda X + 1
09c3: 85 fc     -         sta Y + 1
09c5: a9 00     -         lda	#WALL
09c7: a2 04     -         ldx #4
09c9: a0 00     - block:  ldy #0
09cb: 91 fb     - fill:   sta (ZP1),y
09cd: c8        -         iny
09ce: d0 fb     -         bne fill
09d0: e6 fc     -         inc ZP2
09d2: ca        -         dex
09d3: d0 f4     -         bne block
09d5: 60        -         rts
09d6: ad b6 13  - MAZE_DOT:lda X
09d9: 85 fb     -         sta Y
09db: ad b7 13  -         lda X + 1
09de: 85 fc     -         sta Y + 1
09e0: a9 00     -         lda #0
09e2: 85 fe     -         sta ZP4				
09e4: ad b9 13  -         lda grid+1		
09e7: 85 fd     -         sta ZP3
09e9: a0 03     -         ldy #03
09eb: 06 fd     - mul8:   asl X
09ed: 26 fe     -         rol X+1	
09ef: 88        -         dey
09f0: d0 f9     -         bne mul8
09f2: 18        -         clc
09f3: a5 fb     -         lda X
09f5: 65 fd     -         adc Y
09f7: 85 fb     -         sta X
09f9: 90 02     -         bcc skip
09fb: e6 fc     -         inc X+1
09fd: 18        - skip:   clc
09fe: a5 fc     -         lda X+1
0a00: 65 fe     -         adc Y+1
0a02: 85 fc     -         sta X+1	
0a04: a0 02     -         ldy #02	
0a06: 06 fd     - mul32:  asl X
0a08: 26 fe     -         rol X+1	
0a0a: 88        -         dey
0a0b: d0 f9     -         bne mul32
0a0d: 18        -         clc
0a0e: a5 fb     -         lda X
0a10: 65 fd     -         adc Y
0a12: 85 fb     -         sta X
0a14: 90 02     -         bcc skip
0a16: e6 fc     -         inc X+1
0a18: 18        - skip:   clc
0a19: a5 fc     -         lda X+1
0a1b: 65 fe     -         adc Y+1
0a1d: 85 fc     -         sta X+1	
0a1f: 18        -         clc
0a20: a5 fb     -         lda X
0a22: 6d b8 13  -         adc y	
0a25: 85 fb     -         sta X
0a27: 90 02     -         bcc out+2
0a29: e6 fc     - out:    inc X+1
0a2b: a9 20     -         lda #DOT
0a2d: a0 00     -         ldy #0
0a2f: 91 fb     -         sta (ZP1),y
0a31: 60        -         rts
0a32: 20 c1 0f  - ROOMS:  jsr MAKE_ROOMS
0a35: 20 39 0a  -         jsr PAINT_ROOMS
0a38: 60        -         rts
0a39: a2 00     - PAINT_ROOMS:ldx #00
0a3b: 86 3f     - each:   stx TEMPX				//each room
0a3d: 8a        -         txa
0a3e: 0a        -         asl
0a3f: 0a        -         asl
0a40: a8        -         tay
0a41: b9 df 13  -         lda rooms,y				//get top left x of room
0a44: 85 4e     -         sta BV9
0a46: c8        -         iny
0a47: b9 df 13  -         lda rooms,y				//get top left y of room
0a4a: 85 4f     -         sta BV10
0a4c: c8        -         iny
0a4d: b9 df 13  -         lda rooms,y 			//w
0a50: 85 02     -         sta ZP0
0a52: c8        -         iny
0a53: b9 df 13  -         lda rooms,y 			//h
0a56: 85 52     -         sta BV0
0a58: a2 00     -         ldx #0
0a5a: a0 00     - cont_w: ldy #0
0a5c: 86 41     - cont_h: stx TEMPA1
0a5e: a5 4e     -         lda BV9
0a60: 18        -         clc
0a61: 65 41     -         adc TEMPA1
0a63: 8d b8 13  -         sta maze_start
0a66: 84 41     -         sty TEMPA1
0a68: a5 4f     -         lda BV10
0a6a: 18        -         clc
0a6b: 65 41     -         adc TEMPA1
0a6d: 8d b9 13  -         sta maze_start+1
0a70: 84 40     -         sty TEMPY
0a72: 20 d6 09  -         jsr MAZE_DOT
0a75: a4 40     -         ldy TEMPY
0a77: c8        -         iny
0a78: c4 52     -         cpy BV0
0a7a: d0 e0     -         bne cont_h
0a7c: e8        -         inx
0a7d: e4 02     -         cpx ZP0
0a7f: d0 d9     -         bne cont_w
0a81: a6 3f     -         ldx TEMPX
0a83: e8        -         inx
0a84: e0 04     -         cpx #ROOM_NUMBER
0a86: d0 b3     -         bne each
0a88: 60        - out:    rts
0a89: a2 03     - POINTERS_FROM_START:ldx #03
0a8b: 8a        - add:    txa
0a8c: 0a        -         asl
0a8d: a8        -         tay		
0a8e: 18        -         clc
0a8f: ad b8 13  -         lda maze_start
0a92: 79 ab 09  -         adc BASIC_DIRS,y
0a95: 99 c0 13  -         sta candidates,y
0a98: c8        -         iny
0a99: 18        -         clc
0a9a: ad b9 13  -         lda maze_start+1
0a9d: 79 ab 09  -         adc BASIC_DIRS,y
0aa0: 99 c0 13  -         sta candidates,y
0aa3: ca        -         dex
0aa4: 10 e5     -         bpl add
0aa6: a2 03     -         ldx #03
0aa8: 8a        - copy:   txa
0aa9: 0a        -         asl
0aaa: a8        -         tay	
0aab: b9 ab 09  -         lda BASIC_DIRS,y
0aae: 99 c8 13  -         sta candidates_vectors,y
0ab1: c8        -         iny
0ab2: b9 ab 09  -         lda BASIC_DIRS,y
0ab5: 99 c8 13  -         sta candidates_vectors,y
0ab8: ca        -         dex
0ab9: 10 ed     -         bpl copy
0abb: a9 04     -         lda #04
0abd: 8d d0 13  -         sta candidates_length
0ac0: 60        -         rts
0ac1: ad d0 13  - FILTER_IF_OUT:lda candidates_length
0ac4: c9 01     -         cmp #1
0ac6: b0 01     -         bcs start
0ac8: 60        -         rts
0ac9: ae d0 13  - start:  ldx candidates_length				//number of grids yet to check
0acc: ca        -         dex
0acd: 8a        - each:   txa
0ace: 0a        -         asl
0acf: a8        -         tay
0ad0: 18        -         clc
0ad1: b9 c0 13  -         lda candidates,y
0ad4: c9 27     -         cmp #MAX_X+1
0ad6: b0 18     -         bcs shift
0ad8: c9 01     -         cmp #MIN_X
0ada: 90 14     -         bcc shift
0adc: c8        -         iny
0add: 18        -         clc
0ade: b9 c0 13  -         lda candidates,y
0ae1: c9 18     -         cmp #MAX_Y+1
0ae3: b0 0b     -         bcs shift
0ae5: c9 01     -         cmp #MIN_Y
0ae7: 90 07     -         bcc shift
0ae9: ca        - cont:   dex
0aea: 30 03     -         bmi out
0aec: 4c cd 0a  -         jmp each
0aef: 60        - out:    rts
0af0: 86 3f     - shift:  stx TEMPX									//save x							
0af2: 86 47     -         stx VAR_A									//set index to VAR_A
0af4: ad d0 13  -         lda X
0af7: 85 48     -         sta Y
0af9: a9 c0     -         lda #<addr
0afb: 85 43     -         sta X
0afd: a9 13     -         lda #>addr
0aff: 85 44     -         sta X+1
0b01: a9 02     -         lda #data_size
0b03: 85 49     -         sta VAR_C
0b05: 20 ae 08  -         jsr SPLICE
0b08: ad d0 13  -         lda X
0b0b: 85 48     -         sta Y
0b0d: a9 c8     -         lda #<addr
0b0f: 85 43     -         sta X
0b11: a9 13     -         lda #>addr
0b13: 85 44     -         sta X+1
0b15: a9 02     -         lda #data_size
0b17: 85 49     -         sta VAR_C
0b19: 20 ae 08  -         jsr SPLICE
0b1c: ce d0 13  -         dec candidates_length						//dec array length
0b1f: a6 3f     -         ldx TEMPX									//restore x
0b21: 4c e9 0a  -         jmp cont									//return to loop
0b24: ad d0 13  - FILTER_IF_DOT:lda candidates_length
0b27: c9 01     -         cmp #1
0b29: b0 01     -         bcs start
0b2b: 60        -         rts
0b2c: ae d0 13  - start:  ldx candidates_length						//number of grids yet to check
0b2f: ca        -         dex
0b30: 8a        - each:   txa
0b31: 0a        -         asl
0b32: a8        -         tay
0b33: b9 c0 13  -         lda candidates,y
0b36: 8d ba 13  -         sta grid_pointer
0b39: c8        -         iny
0b3a: b9 c0 13  -         lda candidates,y
0b3d: 8d bb 13  -         sta grid_pointer+1
0b40: ad b6 13  -         lda X
0b43: 85 fb     -         sta Y
0b45: ad b7 13  -         lda X + 1
0b48: 85 fc     -         sta Y + 1
0b4a: a9 00     -         lda #0
0b4c: 85 fe     -         sta ZP4				
0b4e: ad bb 13  -         lda grid+1		
0b51: 85 fd     -         sta ZP3
0b53: a0 03     -         ldy #03
0b55: 06 fd     - mul8:   asl X
0b57: 26 fe     -         rol X+1	
0b59: 88        -         dey
0b5a: d0 f9     -         bne mul8
0b5c: 18        -         clc
0b5d: a5 fb     -         lda X
0b5f: 65 fd     -         adc Y
0b61: 85 fb     -         sta X
0b63: 90 02     -         bcc skip
0b65: e6 fc     -         inc X+1
0b67: 18        - skip:   clc
0b68: a5 fc     -         lda X+1
0b6a: 65 fe     -         adc Y+1
0b6c: 85 fc     -         sta X+1	
0b6e: a0 02     -         ldy #02	
0b70: 06 fd     - mul32:  asl X
0b72: 26 fe     -         rol X+1	
0b74: 88        -         dey
0b75: d0 f9     -         bne mul32
0b77: 18        -         clc
0b78: a5 fb     -         lda X
0b7a: 65 fd     -         adc Y
0b7c: 85 fb     -         sta X
0b7e: 90 02     -         bcc skip
0b80: e6 fc     -         inc X+1
0b82: 18        - skip:   clc
0b83: a5 fc     -         lda X+1
0b85: 65 fe     -         adc Y+1
0b87: 85 fc     -         sta X+1	
0b89: 18        -         clc
0b8a: a5 fb     -         lda X
0b8c: 6d ba 13  -         adc y	
0b8f: 85 fb     -         sta X
0b91: 90 02     -         bcc out+2
0b93: e6 fc     - out:    inc X+1
0b95: a0 00     -         ldy #0
0b97: b1 fb     -         lda (ZP1),y
0b99: c9 20     -         cmp #DOT
0b9b: f0 04     -         beq shift
0b9d: ca        - cont:   dex
0b9e: 10 90     -         bpl each
0ba0: 60        - out:    rts
0ba1: 86 3f     - shift:  stx TEMPX									//save x
0ba3: 86 47     -         stx VAR_A									//set index to VAR_A
0ba5: ad d0 13  -         lda X
0ba8: 85 48     -         sta Y
0baa: a9 c0     -         lda #<addr
0bac: 85 43     -         sta X
0bae: a9 13     -         lda #>addr
0bb0: 85 44     -         sta X+1
0bb2: a9 02     -         lda #data_size
0bb4: 85 49     -         sta VAR_C
0bb6: 20 ae 08  -         jsr SPLICE
0bb9: ad d0 13  -         lda X
0bbc: 85 48     -         sta Y
0bbe: a9 c8     -         lda #<addr
0bc0: 85 43     -         sta X
0bc2: a9 13     -         lda #>addr
0bc4: 85 44     -         sta X+1
0bc6: a9 02     -         lda #data_size
0bc8: 85 49     -         sta VAR_C
0bca: 20 ae 08  -         jsr SPLICE
0bcd: ce d0 13  -         dec candidates_length						//dec array length
0bd0: a6 3f     -         ldx TEMPX									//restore x
0bd2: 4c 9d 0b  -         jmp cont									//return to loop
0bd5: a5 02     - PUSH_REST_ON_STACK:lda ZP0										//index was stored in ZP0
0bd7: 85 47     -         sta VAR_A									//set index to VAR_A
0bd9: ad d0 13  -         lda X
0bdc: 85 48     -         sta Y
0bde: a9 c0     -         lda #<addr
0be0: 85 43     -         sta X
0be2: a9 13     -         lda #>addr
0be4: 85 44     -         sta X+1
0be6: a9 02     -         lda #data_size
0be8: 85 49     -         sta VAR_C
0bea: 20 ae 08  -         jsr SPLICE
0bed: ad d0 13  -         lda X
0bf0: 85 48     -         sta Y
0bf2: a9 c8     -         lda #<addr
0bf4: 85 43     -         sta X
0bf6: a9 13     -         lda #>addr
0bf8: 85 44     -         sta X+1
0bfa: a9 02     -         lda #data_size
0bfc: 85 49     -         sta VAR_C
0bfe: 20 ae 08  -         jsr SPLICE
0c01: ce d0 13  -         dec candidates_length						//dec array length
0c04: a2 00     -         ldx #0
0c06: a0 00     - each:   ldy #0
0c08: 86 3f     -         stx TEMPX									//save x
0c0a: 8a        -         txa											//x = x *2	
0c0b: 0a        -         asl 
0c0c: aa        -         tax									
0c0d: bd c0 13  -         lda candidates,x							//x
0c10: 91 71     -         sta (STKPTR1),y
0c12: c8        -         iny
0c13: e8        -         inx
0c14: bd c0 13  -         lda candidates,x							//y
0c17: 91 71     -         sta (STKPTR1),y
0c19: 18        -         clc
0c1a: a5 71     -         lda X
0c1c: 69 02     -         adc #C
0c1e: 85 71     -         sta X
0c20: 90 02     -         bcc out+2
0c22: e6 72     - out:    inc X+1
0c24: 88        -         dey
0c25: ca        -         dex
0c26: bd c8 13  -         lda candidates_vectors,x					//x
0c29: 91 71     -         sta (STKPTR1),y
0c2b: c8        -         iny
0c2c: e8        -         inx
0c2d: bd c8 13  -         lda candidates_vectors,x					//y
0c30: 91 71     -         sta (STKPTR1),y
0c32: 18        -         clc
0c33: a5 71     -         lda X
0c35: 69 02     -         adc #C
0c37: 85 71     -         sta X
0c39: 90 02     -         bcc out+2
0c3b: e6 72     - out:    inc X+1
0c3d: a6 3f     -         ldx TEMPX									//restore x
0c3f: e8        -         inx
0c40: ec d0 13  -         cpx candidates_length
0c43: d0 c1     -         bne each
0c45: 60        - out:    rts		
0c46: ad d0 13  - FILTER_IF_NEXT_PRIMARY:lda candidates_length
0c49: c9 01     -         cmp #1
0c4b: b0 01     -         bcs start										//cont if 1 or more
0c4d: 60        -         rts												//else exit, if no candidates
0c4e: ae d0 13  - start:  ldx candidates_length							//number of grids yet to check
0c51: ca        -         dex												//to zero offset
0c52: 8a        - each:   txa
0c53: 0a        -         asl												//double, because datasize is 2
0c54: a8        -         tay												//offset in y (zero based x * datasize)
0c55: b9 c0 13  -         lda candidates,y
0c58: 8d ba 13  -         sta grid_pointer
0c5b: b9 c8 13  -         lda candidates_vectors,y
0c5e: 8d bc 13  -         sta direction_pointer
0c61: c8        -         iny
0c62: b9 c0 13  -         lda candidates,y
0c65: 8d bb 13  -         sta grid_pointer+1
0c68: b9 c8 13  -         lda candidates_vectors,y
0c6b: 8d bd 13  -         sta direction_pointer+1
0c6e: 18        -         clc
0c6f: ad ba 13  -         lda grid_pointer
0c72: 6d bc 13  -         adc direction_pointer
0c75: 8d be 13  -         sta test_pointer
0c78: 18        -         clc
0c79: ad bb 13  -         lda grid_pointer+1
0c7c: 6d bd 13  -         adc direction_pointer+1
0c7f: 8d bf 13  -         sta test_pointer+1
0c82: ad b6 13  -         lda X
0c85: 85 fb     -         sta Y
0c87: ad b7 13  -         lda X + 1
0c8a: 85 fc     -         sta Y + 1
0c8c: a9 00     -         lda #0
0c8e: 85 fe     -         sta ZP4				
0c90: ad bf 13  -         lda grid+1		
0c93: 85 fd     -         sta ZP3
0c95: a0 03     -         ldy #03
0c97: 06 fd     - mul8:   asl X
0c99: 26 fe     -         rol X+1	
0c9b: 88        -         dey
0c9c: d0 f9     -         bne mul8
0c9e: 18        -         clc
0c9f: a5 fb     -         lda X
0ca1: 65 fd     -         adc Y
0ca3: 85 fb     -         sta X
0ca5: 90 02     -         bcc skip
0ca7: e6 fc     -         inc X+1
0ca9: 18        - skip:   clc
0caa: a5 fc     -         lda X+1
0cac: 65 fe     -         adc Y+1
0cae: 85 fc     -         sta X+1	
0cb0: a0 02     -         ldy #02	
0cb2: 06 fd     - mul32:  asl X
0cb4: 26 fe     -         rol X+1	
0cb6: 88        -         dey
0cb7: d0 f9     -         bne mul32
0cb9: 18        -         clc
0cba: a5 fb     -         lda X
0cbc: 65 fd     -         adc Y
0cbe: 85 fb     -         sta X
0cc0: 90 02     -         bcc skip
0cc2: e6 fc     -         inc X+1
0cc4: 18        - skip:   clc
0cc5: a5 fc     -         lda X+1
0cc7: 65 fe     -         adc Y+1
0cc9: 85 fc     -         sta X+1	
0ccb: 18        -         clc
0ccc: a5 fb     -         lda X
0cce: 6d be 13  -         adc y	
0cd1: 85 fb     -         sta X
0cd3: 90 02     -         bcc out+2
0cd5: e6 fc     - out:    inc X+1
0cd7: a0 00     -         ldy #0
0cd9: b1 fb     -         lda (ZP1),y
0cdb: c5 52     -         cmp BV0										//BV0 holds the value to filter out
0cdd: f0 07     -         beq shift									//yes
0cdf: ca        - cont:   dex
0ce0: 30 03     -         bmi out										//less than zero, stop
0ce2: 4c 52 0c  -         jmp each									//loop back, branch too far
0ce5: 60        - out:    rts
0ce6: 86 3f     - shift:  stx TEMPX									//save x
0ce8: 86 47     -         stx VAR_A									//set index to VAR_A
0cea: ad d0 13  -         lda X
0ced: 85 48     -         sta Y
0cef: a9 c0     -         lda #<addr
0cf1: 85 43     -         sta X
0cf3: a9 13     -         lda #>addr
0cf5: 85 44     -         sta X+1
0cf7: a9 02     -         lda #data_size
0cf9: 85 49     -         sta VAR_C
0cfb: 20 ae 08  -         jsr SPLICE
0cfe: ad d0 13  -         lda X
0d01: 85 48     -         sta Y
0d03: a9 c8     -         lda #<addr
0d05: 85 43     -         sta X
0d07: a9 13     -         lda #>addr
0d09: 85 44     -         sta X+1
0d0b: a9 02     -         lda #data_size
0d0d: 85 49     -         sta VAR_C
0d0f: 20 ae 08  -         jsr SPLICE
0d12: ce d0 13  -         dec candidates_length						//dec array length
0d15: a6 3f     -         ldx TEMPX									//restore x
0d17: 4c df 0c  -         jmp cont									//return to loop
0d1a: ad d0 13  - FILTER_N_CONNECTIONS:lda candidates_length
0d1d: c9 01     -         cmp #1
0d1f: b0 01     -         bcs start										//cont if 1 or more
0d21: 60        -         rts												//else exit, if no candidates
0d22: ae d0 13  - start:  ldx candidates_length							//number of grids yet to check
0d25: ca        -         dex												//to zero offset
0d26: 86 3f     - each:   stx TEMPX										// save x 
0d28: 8a        -         txa
0d29: 0a        -         asl												//double, because datasize is 2
0d2a: a8        -         tay												//offset in y (zero based x * datasize)
0d2b: b9 c0 13  -         lda candidates,y
0d2e: 8d ba 13  -         sta grid_pointer
0d31: c8        -         iny
0d32: b9 c0 13  -         lda candidates,y
0d35: 8d bb 13  -         sta grid_pointer+1
0d38: ad ba 13  -         lda bridge
0d3b: 85 50     -         sta BV7
0d3d: ad bb 13  -         lda bridge+1
0d40: 85 51     -         sta BV8
0d42: a9 00     -         lda #0
0d44: 85 4a     -         sta VAR_D
0d46: 20 7c 12  -         jsr CHECK_CONNECTION
0d49: a6 3f     -         ldx TEMPX										//restore x
0d4b: a5 4a     -         lda VAR_D										//value to compare is in BV0
0d4d: c5 52     -         cmp BV0
0d4f: d0 07     -         bne shift										//not equal, shift											
0d51: ca        - cont:   dex
0d52: 30 03     -         bmi out											//less than zero, stop
0d54: 4c 26 0d  -         jmp each										//loop back, branch too far
0d57: 60        - out:    rts
0d58: 86 3f     - shift:  stx TEMPX									//save x
0d5a: 86 47     -         stx VAR_A									//set index to VAR_A
0d5c: ad d0 13  -         lda X
0d5f: 85 48     -         sta Y
0d61: a9 c0     -         lda #<addr
0d63: 85 43     -         sta X
0d65: a9 13     -         lda #>addr
0d67: 85 44     -         sta X+1
0d69: a9 02     -         lda #data_size
0d6b: 85 49     -         sta VAR_C
0d6d: 20 ae 08  -         jsr SPLICE
0d70: ad d0 13  -         lda X
0d73: 85 48     -         sta Y
0d75: a9 c8     -         lda #<addr
0d77: 85 43     -         sta X
0d79: a9 13     -         lda #>addr
0d7b: 85 44     -         sta X+1
0d7d: a9 02     -         lda #data_size
0d7f: 85 49     -         sta VAR_C
0d81: 20 ae 08  -         jsr SPLICE
0d84: ce d0 13  -         dec candidates_length						//dec array length
0d87: a6 3f     -         ldx TEMPX									//restore x
0d89: 4c 51 0d  -         jmp cont									//return to loop
0d8c: ad d0 13  - FILTER_SIDE_PROXIMIY:lda candidates_length
0d8f: c9 01     -         cmp #1
0d91: b0 01     -         bcs start										//cont if 1 or more
0d93: 60        -         rts												//else exit, if no candidates
0d94: ae d0 13  - start:  ldx candidates_length							//number of grids yet to check
0d97: ca        -         dex												//to zero offset
0d98: 8a        - each:   txa
0d99: 0a        -         asl												//double, because datasize is 2
0d9a: a8        -         tay												//offset in y (zero based x * datasize)
0d9b: b9 c0 13  -         lda candidates, y
0d9e: 8d ba 13  -         sta grid_pointer
0da1: b9 c8 13  -         lda candidates_vectors,y
0da4: 8d bc 13  -         sta direction_pointer
0da7: c8        -         iny
0da8: b9 c0 13  -         lda candidates, y
0dab: 8d bb 13  -         sta grid_pointer+1
0dae: b9 c8 13  -         lda candidates_vectors,y
0db1: 8d bd 13  -         sta direction_pointer+1
0db4: a9 b3     -         lda #<addr
0db6: 85 50     -         sta X
0db8: a9 09     -         lda #>addr
0dba: 85 51     -         sta X+1
0dbc: a9 d1     -         lda #<addr
0dbe: 85 4e     -         sta X
0dc0: a9 13     -         lda #>addr
0dc2: 85 4f     -         sta X+1
0dc4: a0 08     -         ldy #length											
0dc6: 88        -         dey
0dc7: b1 50     - copy:   lda (BV7),y
0dc9: 91 4e     -         sta (BV9),y
0dcb: 88        -         dey
0dcc: 10 f9     -         bpl copy
0dce: a0 01     -         ldy #01											//y?
0dd0: b9 bc 13  -         lda direction_pointer,y
0dd3: d0 01     -         bne ok											//if not zero, than this is right dimension
0dd5: 88        -         dey												//not y, but x
0dd6: b9 bc 13  - ok:     lda direction_pointer,y							//index of dimension now in y register
0dd9: 99 d1 13  -         sta proximity_vectors,y							//set sequence 1,1,0,0 on the right dimension, datasize=2
0ddc: c8        -         iny
0ddd: c8        -         iny
0dde: 99 d1 13  -         sta proximity_vectors,y	
0de1: c8        -         iny
0de2: c8        -         iny
0de3: a9 00     -         lda #0
0de5: 99 d1 13  -         sta proximity_vectors,y	
0de8: c8        -         iny
0de9: c8        -         iny
0dea: 99 d1 13  -         sta proximity_vectors,y							//proximity vectors ready
0ded: a0 00     -         ldy #00
0def: ad ba 13  - repeat: lda grid_pointer
0df2: 18        -         clc
0df3: 79 d1 13  -         adc proximity_vectors,y
0df6: 8d be 13  -         sta test_pointer
0df9: c8        -         iny
0dfa: ad bb 13  -         lda grid_pointer+1
0dfd: 18        -         clc
0dfe: 79 d1 13  -         adc proximity_vectors,y
0e01: 8d bf 13  -         sta test_pointer+1								//next grid now in test_pointer
0e04: 84 40     -         sty TEMPY										//save y
0e06: ad b6 13  -         lda X
0e09: 85 fb     -         sta Y
0e0b: ad b7 13  -         lda X + 1
0e0e: 85 fc     -         sta Y + 1
0e10: a9 00     -         lda #0
0e12: 85 fe     -         sta ZP4				
0e14: ad bf 13  -         lda grid+1		
0e17: 85 fd     -         sta ZP3
0e19: a0 03     -         ldy #03
0e1b: 06 fd     - mul8:   asl X
0e1d: 26 fe     -         rol X+1	
0e1f: 88        -         dey
0e20: d0 f9     -         bne mul8
0e22: 18        -         clc
0e23: a5 fb     -         lda X
0e25: 65 fd     -         adc Y
0e27: 85 fb     -         sta X
0e29: 90 02     -         bcc skip
0e2b: e6 fc     -         inc X+1
0e2d: 18        - skip:   clc
0e2e: a5 fc     -         lda X+1
0e30: 65 fe     -         adc Y+1
0e32: 85 fc     -         sta X+1	
0e34: a0 02     -         ldy #02	
0e36: 06 fd     - mul32:  asl X
0e38: 26 fe     -         rol X+1	
0e3a: 88        -         dey
0e3b: d0 f9     -         bne mul32
0e3d: 18        -         clc
0e3e: a5 fb     -         lda X
0e40: 65 fd     -         adc Y
0e42: 85 fb     -         sta X
0e44: 90 02     -         bcc skip
0e46: e6 fc     -         inc X+1
0e48: 18        - skip:   clc
0e49: a5 fc     -         lda X+1
0e4b: 65 fe     -         adc Y+1
0e4d: 85 fc     -         sta X+1	
0e4f: 18        -         clc
0e50: a5 fb     -         lda X
0e52: 6d be 13  -         adc y	
0e55: 85 fb     -         sta X
0e57: 90 02     -         bcc out+2
0e59: e6 fc     - out:    inc X+1
0e5b: a0 00     -         ldy #0
0e5d: b1 fb     -         lda (ZP1),y
0e5f: c9 20     -         cmp #DOT										//is dot? (empty)
0e61: f0 0e     -         beq shift										//yes, shift on x
0e63: a4 40     -         ldy TEMPY										//restore y
0e65: c8        -         iny
0e66: c0 08     -         cpy #08
0e68: d0 85     -         bne repeat
0e6a: ca        - cont:   dex
0e6b: 30 03     -         bmi out										//less than zero, stop
0e6d: 4c 98 0d  -         jmp each									//loop back, branch too far
0e70: 60        - out:    rts
0e71: 86 3f     - shift:  stx TEMPX									//save x
0e73: 86 47     -         stx VAR_A									//set index to VAR_A
0e75: ad d0 13  -         lda X
0e78: 85 48     -         sta Y
0e7a: a9 c0     -         lda #<addr
0e7c: 85 43     -         sta X
0e7e: a9 13     -         lda #>addr
0e80: 85 44     -         sta X+1
0e82: a9 02     -         lda #data_size
0e84: 85 49     -         sta VAR_C
0e86: 20 ae 08  -         jsr SPLICE
0e89: ad d0 13  -         lda X
0e8c: 85 48     -         sta Y
0e8e: a9 c8     -         lda #<addr
0e90: 85 43     -         sta X
0e92: a9 13     -         lda #>addr
0e94: 85 44     -         sta X+1
0e96: a9 02     -         lda #data_size
0e98: 85 49     -         sta VAR_C
0e9a: 20 ae 08  -         jsr SPLICE
0e9d: ce d0 13  -         dec candidates_length						//dec array length
0ea0: a6 3f     -         ldx TEMPX									//restore x
0ea2: 4c 6a 0e  -         jmp cont									//return to loop
0ea5: a5 71     - CANDIDATE_FROM_STACK:lda X
0ea7: 38        -         sec
0ea8: e9 02     -         sbc #C
0eaa: 85 71     -         sta X
0eac: b0 02     -         bcs out+2
0eae: c6 72     - out:    dec X+1
0eb0: a0 00     -         ldy #0									//x
0eb2: b1 71     -         lda (STKPTR1),y
0eb4: 99 c8 13  -         sta candidates_vectors,y
0eb7: c8        -         iny										//y
0eb8: b1 71     -         lda (STKPTR1),y
0eba: 99 c8 13  -         sta candidates_vectors,y
0ebd: a5 71     -         lda X
0ebf: 38        -         sec
0ec0: e9 02     -         sbc #C
0ec2: 85 71     -         sta X
0ec4: b0 02     -         bcs out+2
0ec6: c6 72     - out:    dec X+1
0ec8: a0 00     -         ldy #0									//x
0eca: b1 71     -         lda (STKPTR1),y
0ecc: 99 c0 13  -         sta candidates,y
0ecf: c8        -         iny										//y
0ed0: b1 71     -         lda (STKPTR1),y
0ed2: 99 c0 13  -         sta candidates,y
0ed5: a9 01     -         lda #01
0ed7: 8d d0 13  -         sta candidates_length
0eda: 60        - out:    rts
0edb: ae d0 13  - CHECK_BIAS:ldx candidates_length
0ede: ca        -         dex
0edf: 8a        - each:   txa
0ee0: 0a        -         asl 								// length to offset in
0ee1: a8        -         tay									// y
0ee2: b9 c8 13  -         lda candidates_vectors,y			// x dim
0ee5: cd db 13  -         cmp bias_direction
0ee8: d0 09     -         bne not 							//not same
0eea: c8        -         iny
0eeb: b9 c8 13  -         lda	candidates_vectors,y			// y dim	
0eee: cd dc 13  -         cmp bias_direction+1				//the same
0ef1: f0 06     -         beq found
0ef3: ca        - not:    dex
0ef4: 10 e9     -         bpl each
0ef6: a9 ff     -         lda #-1								//not found: -1
0ef8: 60        -         rts
0ef9: 8a        - found:  txa									//index in acc
0efa: 60        -         rts
0efb: a0 00     - STORE_DEAD_END:ldy #0
0efd: ad b8 13  -         lda maze_start			//x
0f00: 91 5c     -         sta (STKPTR3),y
0f02: c8        -         iny
0f03: ad b9 13  -         lda maze_start+1		//y
0f06: 91 5c     -         sta (STKPTR3),y
0f08: ee dd 13  -         inc DE_counter			//assumption always less than 255
0f0b: 18        -         clc
0f0c: a5 5c     -         lda X
0f0e: 69 02     -         adc #C
0f10: 85 5c     -         sta X
0f12: 90 02     -         bcc out+2
0f14: e6 5d     - out:    inc X+1
0f16: 60        - out:    rts
0f17: a9 00     - CONNECT_DEAD_ENDS:lda #<addr
0f19: 85 5c     -         sta X
0f1b: a9 c4     -         lda #>addr
0f1d: 85 5d     -         sta X+1
0f1f: ae dd 13  -         ldx DE_counter							//starting from last DE towards 0th
0f22: ca        -         dex
0f23: 86 0a     - each_DE:stx GLOBAL_X
0f25: 8a        -         txa
0f26: 0a        -         asl 									//datasize=2
0f27: a8        -         tay										//offset in y
0f28: b1 5c     -         lda (STKPTR3),y
0f2a: 8d b8 13  -         sta maze_start
0f2d: c8        -         iny
0f2e: b1 5c     -         lda (STKPTR3),y
0f30: 8d b9 13  -         sta maze_start+1						//selected Dead End --> in maze_start
0f33: ad b8 13  -         lda bridge
0f36: 85 50     -         sta BV7
0f38: ad b9 13  -         lda bridge+1
0f3b: 85 51     -         sta BV8
0f3d: a9 00     -         lda #0
0f3f: 85 4a     -         sta VAR_D
0f41: 20 7c 12  -         jsr CHECK_CONNECTION
0f44: a5 4a     -         lda VAR_D								//check if still DE (only one grid is dot, rest are wall)
0f46: c9 01     -         cmp #01									//--> number of connections is exactly 1
0f48: f0 03     -         beq still_DE							//yes
0f4a: 4c b8 0f  -         jmp end_loop							//no, check next
0f4d: 20 89 0a  - still_DE:jsr POINTERS_FROM_START					//candidates for bridges in candidates
0f50: 20 c1 0a  -         jsr FILTER_IF_OUT
0f53: 20 24 0b  -         jsr FILTER_IF_DOT
0f56: a9 00     -         lda #test
0f58: 85 52     -         sta BV0
0f5a: 20 46 0c  -         jsr FILTER_IF_NEXT_PRIMARY
0f5d: a9 02     -         lda #N
0f5f: 85 52     -         sta BV0
0f61: 20 1a 0d  -         jsr FILTER_N_CONNECTIONS
0f64: ad d0 13  -         lda candidates_length						//check how many we have
0f67: c9 00     -         cmp #00										//if zero break;
0f69: d0 1e     -         bne more									//more than 0
0f6b: a0 00     -         ldy #0										//store into remainder stack
0f6d: ad b8 13  -         lda maze_start								//x
0f70: 91 5e     -         sta (STKPTR5),y
0f72: c8        -         iny
0f73: ad b9 13  -         lda maze_start+1							//y
0f76: 91 5e     -         sta (STKPTR5),y
0f78: ee de 13  -         inc REM_DE_counter							//assumption always less than 255
0f7b: 18        -         clc
0f7c: a5 5e     -         lda X
0f7e: 69 02     -         adc #C
0f80: 85 5e     -         sta X
0f82: 90 02     -         bcc out+2
0f84: e6 5f     - out:    inc X+1
0f86: 4c b8 0f  -         jmp end_loop								//nothing to paint
0f89: c9 02     - more:   cmp #02										//if it is two or more
0f8b: b0 05     -         bcs select_random							//go to else/select_random
0f8d: a9 00     -         lda #0										//otherwise, index->0 in A									
0f8f: 4c a6 0f  -         jmp skip_else
0f92: ad d0 13  - select_random:lda candidates_length						//random index (, candidates length-1)
0f95: aa        -         tax
0f96: ca        -         dex
0f97: 86 02     -         stx ZP0
0f99: a5 02     -         lda X	
0f9b: 85 fd     -         sta ZP3
0f9d: a9 00     -         lda #0
0f9f: 85 fe     -         sta ZP4
0fa1: 20 7b 09  -         jsr rnd_X
0fa4: a5 14     -         lda WINT
0fa6: 0a        - skip_else:asl 										//datasize=2	
0fa7: a8        -         tay											//offset in y
0fa8: b9 c0 13  -         lda candidates,y	
0fab: 8d b8 13  -         sta maze_start
0fae: c8        -         iny
0faf: b9 c0 13  -         lda candidates,y
0fb2: 8d b9 13  -         sta maze_start+1
0fb5: 20 d6 09  -         jsr MAZE_DOT								//and paint
0fb8: a6 0a     - end_loop:ldx GLOBAL_X
0fba: ca        -         dex
0fbb: 30 03     -         bmi out
0fbd: 4c 23 0f  -         jmp each_DE
0fc0: 60        - out:    rts
0fc1: a2 00     - MAKE_ROOMS:ldx #0
0fc3: 86 3f     - each:   stx TEMPX
0fc5: 8a        -         txa
0fc6: 0a        -         asl
0fc7: 0a        -         asl
0fc8: a8        -         tay					//datasize 4 from x to y
0fc9: a9 00     -         lda #0
0fcb: 85 fc     -         sta ZP2
0fcd: 85 fe     -         sta ZP4
0fcf: b9 ef 13  -         lda room_def,y
0fd2: 85 fb     -         sta ZP1				//x from
0fd4: b9 f0 13  -         lda room_def+1,y
0fd7: 85 fd     -         sta ZP3				//x to
0fd9: 84 40     -         sty TEMPY
0fdb: 20 3a 09  -         jsr rnd_XY
0fde: a5 14     -         lda WINT
0fe0: a4 40     -         ldy TEMPY
0fe2: 99 df 13  -         sta rooms,y			//top x random(from, to)
0fe5: a9 00     -         lda #0
0fe7: 85 fc     -         sta ZP2
0fe9: 85 fe     -         sta ZP4
0feb: b9 f1 13  -         lda room_def+2,y
0fee: 85 fb     -         sta ZP1				//y from
0ff0: b9 f2 13  -         lda room_def+3,y
0ff3: 85 fd     -         sta ZP3				//y to
0ff5: 84 40     -         sty TEMPY
0ff7: 20 3a 09  -         jsr rnd_XY
0ffa: a5 14     -         lda WINT
0ffc: a4 40     -         ldy TEMPY
0ffe: c8        -         iny
0fff: 99 df 13  -         sta rooms,y			//top y random(from, to)
1002: a9 00     -         lda #0
1004: 85 fc     -         sta ZP2
1006: 85 fe     -         sta ZP4
1008: a9 03     -         lda #MIN_W
100a: 85 fb     -         sta ZP1
100c: a9 04     -         lda #MAX_W
100e: 85 fd     -         sta ZP3
1010: 84 40     -         sty TEMPY
1012: 20 3a 09  -         jsr rnd_XY
1015: a5 14     -         lda WINT
1017: a4 40     -         ldy TEMPY
1019: c8        -         iny	
101a: 99 df 13  -         sta rooms,y			//w
101d: a9 00     -         lda #0
101f: 85 fc     -         sta ZP2
1021: 85 fe     -         sta ZP4
1023: a9 03     -         lda #MIN_W
1025: 85 fb     -         sta ZP1
1027: a9 04     -         lda #MAX_W
1029: 85 fd     -         sta ZP3
102b: 84 40     -         sty TEMPY
102d: 20 3a 09  -         jsr rnd_XY
1030: a5 14     -         lda WINT
1032: a4 40     -         ldy TEMPY
1034: c8        -         iny	
1035: 99 df 13  -         sta rooms,y			//h
1038: a6 3f     -         ldx TEMPX
103a: e8        -         inx
103b: e0 04     -         cpx #ROOM_NUMBER
103d: d0 84     -         bne each
103f: 60        - out:    rts
1040: a2 00     - GET_EXIT_CANDIDATES,init:ldx #0
1042: 8e 3f 14  -         stx exit_candidates_length		//reset ...
1045: 0a        -         asl 							//room index in A
1046: 0a        -         asl 							//* 4 and to y	
1047: a8        -         tay								//y offset of room index, datzasize = 4
1048: b9 e0 13  -         lda rooms+1,y					//y
104b: 85 40     -         sta TEMPY
104d: c6 40     -         dec TEMPY						//y-1
104f: 18        -         clc
1050: 79 e2 13  -         adc rooms+3,y
1053: 85 53     -         sta TEMPY2						//y+h
1055: b9 e1 13  -         lda rooms+2,y
1058: 85 02     -         sta ZP0	
105a: b9 df 13  -         lda rooms,y
105d: 85 52     -         sta BV0							//x + i
105f: 84 47     -         sty VAR_A						//save offset of room index
1061: a2 00     -         ldx #00
1063: ad 3f 14  - width_loop:lda	exit_candidates_length
1066: 0a        -         asl 							//datasize of candidates = 2
1067: a8        -         tay								//exit_candidates offset in y
1068: a5 52     -         lda	BV0							//x+i
106a: 99 ff 13  -         sta exit_candidates,y	
106d: a9 00     -         lda #0
106f: 99 1f 14  -         sta exit_candidate_dirs,y
1072: c8        -         iny
1073: a5 40     -         lda TEMPY						//y-1
1075: 99 ff 13  -         sta exit_candidates,y
1078: a9 ff     -         lda #-1							
107a: 99 1f 14  -         sta exit_candidate_dirs,y
107d: c8        -         iny
107e: ee 3f 14  -         inc exit_candidates_length
1081: a5 52     -         lda	BV0							//x+i
1083: 99 ff 13  -         sta exit_candidates,y	
1086: a9 00     -         lda #0
1088: 99 1f 14  -         sta exit_candidate_dirs,y
108b: c8        -         iny
108c: a5 53     -         lda TEMPY2						//y+h
108e: 99 ff 13  -         sta	exit_candidates,y	
1091: a9 01     -         lda #1
1093: 99 1f 14  -         sta exit_candidate_dirs,y
1096: ee 3f 14  -         inc exit_candidates_length		
1099: e6 52     -         inc BV0							//i++
109b: e8        -         inx
109c: e4 02     -         cpx ZP0
109e: d0 c3     -         bne width_loop
10a0: a4 47     -         ldy VAR_A						//restore offset of room index
10a2: b9 df 13  -         lda rooms,y						//x
10a5: 85 3f     -         sta TEMPX
10a7: c6 3f     -         dec TEMPX						//x-1
10a9: 18        -         clc
10aa: 79 e1 13  -         adc rooms+2,y
10ad: 85 4d     -         sta TEMPX2						//x+w
10af: b9 e2 13  -         lda rooms+3,y					//h
10b2: 85 02     -         sta ZP0
10b4: b9 e0 13  -         lda rooms+1,y
10b7: 85 52     -         sta BV0							//y + i
10b9: a2 00     -         ldx #00
10bb: ad 3f 14  - height_loop:lda	exit_candidates_length
10be: 0a        -         asl 							//datasize of candidates = 2
10bf: a8        -         tay								//exit_candidates offset in y
10c0: a5 3f     -         lda TEMPX						//x-1
10c2: 99 ff 13  -         sta exit_candidates,y
10c5: a9 ff     -         lda #-1
10c7: 99 1f 14  -         sta exit_candidate_dirs,y
10ca: c8        -         iny
10cb: a5 52     -         lda BV0							//y+i
10cd: 99 ff 13  -         sta exit_candidates,y
10d0: a9 00     -         lda #0
10d2: 99 1f 14  -         sta exit_candidate_dirs,y
10d5: c8        -         iny
10d6: ee 3f 14  -         inc exit_candidates_length
10d9: a5 4d     -         lda TEMPX2						//x+w
10db: 99 ff 13  -         sta exit_candidates,y
10de: a9 01     -         lda #01
10e0: 99 1f 14  -         sta exit_candidate_dirs,y
10e3: c8        -         iny
10e4: a5 52     -         lda BV0							//y+i
10e6: 99 ff 13  -         sta exit_candidates,y
10e9: a9 00     -         lda #0
10eb: 99 1f 14  -         sta exit_candidate_dirs,y
10ee: c8        -         iny
10ef: ee 3f 14  -         inc exit_candidates_length
10f2: e6 52     -         inc BV0							//i++
10f4: e8        -         inx
10f5: e4 02     -         cpx ZP0
10f7: d0 c2     -         bne height_loop				
10f9: 60        - out:    rts
10fa: a9 00     - SET_START:lda #0							//room index in A
10fc: 20 40 10  -         jsr GET_EXIT_CANDIDATES
10ff: ad 3f 14  -         lda exit_candidates_length
1102: 85 02     -         sta ZP0
1104: c6 02     -         dec ZP0
1106: a5 02     -         lda X	
1108: 85 fd     -         sta ZP3
110a: a9 00     -         lda #0
110c: 85 fe     -         sta ZP4
110e: 20 7b 09  -         jsr rnd_X
1111: a5 14     -         lda WINT
1113: 0a        -         asl 
1114: a8        -         tay
1115: b9 ff 13  -         lda exit_candidates,y
1118: 8d b8 13  -         sta maze_start
111b: c8        -         iny
111c: b9 ff 13  -         lda exit_candidates,y
111f: 8d b9 13  -         sta maze_start+1
1122: 60        - out:    rts
1123: a2 01     - CONNECT_ROOMS:ldx #01												//start with index 1, 0 should be already connected
1125: 86 0a     - each:   stx GLOBAL_X											//save x
1127: 8a        -         txa													//GET_EXIT_CANDIDATES expects room index in A
1128: 20 40 10  -         jsr GET_EXIT_CANDIDATES								//trashes TEMPX
112b: ac 3f 14  - get_one:ldy exit_candidates_length
112e: 88        -         dey
112f: 84 02     -         sty ZP0
1131: a5 02     -         lda X	
1133: 85 fd     -         sta ZP3
1135: a9 00     -         lda #0
1137: 85 fe     -         sta ZP4
1139: 20 7b 09  -         jsr rnd_X
113c: a5 14     -         lda WINT											//random index
113e: 0a        -         asl 
113f: a8        -         tay													//offset in y
1140: b9 ff 13  -         lda exit_candidates,y
1143: 8d ba 13  -         sta grid_pointer									//bridge
1146: b9 1f 14  -         lda exit_candidate_dirs,y
1149: 8d bc 13  -         sta direction_pointer								//dir to test
114c: c8        -         iny
114d: b9 ff 13  -         lda exit_candidates,y
1150: 8d bb 13  -         sta grid_pointer+1
1153: b9 1f 14  -         lda exit_candidate_dirs,y
1156: 8d bd 13  -         sta direction_pointer+1							
1159: ad ba 13  -         lda grid_pointer
115c: 18        -         clc
115d: 6d bc 13  -         adc direction_pointer
1160: 8d be 13  -         sta test_pointer
1163: ad bb 13  -         lda grid_pointer+1
1166: 18        -         clc
1167: 6d bd 13  -         adc direction_pointer+1
116a: 8d bf 13  -         sta test_pointer+1
116d: ad b6 13  -         lda X
1170: 85 fb     -         sta Y
1172: ad b7 13  -         lda X + 1
1175: 85 fc     -         sta Y + 1
1177: a9 00     -         lda #0
1179: 85 fe     -         sta ZP4				
117b: ad bf 13  -         lda grid+1		
117e: 85 fd     -         sta ZP3
1180: a0 03     -         ldy #03
1182: 06 fd     - mul8:   asl X
1184: 26 fe     -         rol X+1	
1186: 88        -         dey
1187: d0 f9     -         bne mul8
1189: 18        -         clc
118a: a5 fb     -         lda X
118c: 65 fd     -         adc Y
118e: 85 fb     -         sta X
1190: 90 02     -         bcc skip
1192: e6 fc     -         inc X+1
1194: 18        - skip:   clc
1195: a5 fc     -         lda X+1
1197: 65 fe     -         adc Y+1
1199: 85 fc     -         sta X+1	
119b: a0 02     -         ldy #02	
119d: 06 fd     - mul32:  asl X
119f: 26 fe     -         rol X+1	
11a1: 88        -         dey
11a2: d0 f9     -         bne mul32
11a4: 18        -         clc
11a5: a5 fb     -         lda X
11a7: 65 fd     -         adc Y
11a9: 85 fb     -         sta X
11ab: 90 02     -         bcc skip
11ad: e6 fc     -         inc X+1
11af: 18        - skip:   clc
11b0: a5 fc     -         lda X+1
11b2: 65 fe     -         adc Y+1
11b4: 85 fc     -         sta X+1	
11b6: 18        -         clc
11b7: a5 fb     -         lda X
11b9: 6d be 13  -         adc y	
11bc: 85 fb     -         sta X
11be: 90 02     -         bcc out+2
11c0: e6 fc     - out:    inc X+1
11c2: a0 00     -         ldy #0
11c4: b1 fb     -         lda (ZP1),y
11c6: c9 20     -         cmp #DOT											//is it dot
11c8: f0 32     -         beq check_connections								//yes, check connections
11ca: a5 14     -         lda WINT											//random index was still in WINT
11cc: 85 47     -         sta VAR_A											//store index in VAR_A
11ce: ad 3f 14  -         lda X
11d1: 85 48     -         sta Y
11d3: a9 ff     -         lda #<addr
11d5: 85 43     -         sta X
11d7: a9 13     -         lda #>addr
11d9: 85 44     -         sta X+1
11db: a9 02     -         lda #data_size
11dd: 85 49     -         sta VAR_C
11df: 20 ae 08  -         jsr SPLICE
11e2: ad 3f 14  -         lda X
11e5: 85 48     -         sta Y
11e7: a9 1f     -         lda #<addr
11e9: 85 43     -         sta X
11eb: a9 14     -         lda #>addr
11ed: 85 44     -         sta X+1
11ef: a9 02     -         lda #data_size
11f1: 85 49     -         sta VAR_C
11f3: 20 ae 08  -         jsr SPLICE
11f6: ce 3f 14  -         dec exit_candidates_length							//exit_candidates_length--
11f9: 4c 2b 11  -         jmp get_one											//try another
11fc: ad ba 13  - check_connections:lda bridge
11ff: 85 50     -         sta BV7
1201: ad bb 13  -         lda bridge+1
1204: 85 51     -         sta BV8
1206: a9 00     -         lda #0
1208: 85 4a     -         sta VAR_D
120a: 20 7c 12  -         jsr CHECK_CONNECTION
120d: a5 4a     -         lda VAR_D
120f: c9 02     -         cmp #02												//exactly two directions required for bridge
1211: f0 03     -         beq yes												//yes, paint
1213: 4c 2b 11  -         jmp get_one											//not ok, get another
1216: ad b6 13  - yes:    lda X
1219: 85 fb     -         sta Y
121b: ad b7 13  -         lda X + 1
121e: 85 fc     -         sta Y + 1
1220: a9 00     -         lda #0
1222: 85 fe     -         sta ZP4				
1224: ad bb 13  -         lda grid+1		
1227: 85 fd     -         sta ZP3
1229: a0 03     -         ldy #03
122b: 06 fd     - mul8:   asl X
122d: 26 fe     -         rol X+1	
122f: 88        -         dey
1230: d0 f9     -         bne mul8
1232: 18        -         clc
1233: a5 fb     -         lda X
1235: 65 fd     -         adc Y
1237: 85 fb     -         sta X
1239: 90 02     -         bcc skip
123b: e6 fc     -         inc X+1
123d: 18        - skip:   clc
123e: a5 fc     -         lda X+1
1240: 65 fe     -         adc Y+1
1242: 85 fc     -         sta X+1	
1244: a0 02     -         ldy #02	
1246: 06 fd     - mul32:  asl X
1248: 26 fe     -         rol X+1	
124a: 88        -         dey
124b: d0 f9     -         bne mul32
124d: 18        -         clc
124e: a5 fb     -         lda X
1250: 65 fd     -         adc Y
1252: 85 fb     -         sta X
1254: 90 02     -         bcc skip
1256: e6 fc     -         inc X+1
1258: 18        - skip:   clc
1259: a5 fc     -         lda X+1
125b: 65 fe     -         adc Y+1
125d: 85 fc     -         sta X+1	
125f: 18        -         clc
1260: a5 fb     -         lda X
1262: 6d ba 13  -         adc y	
1265: 85 fb     -         sta X
1267: 90 02     -         bcc out+2
1269: e6 fc     - out:    inc X+1
126b: a9 20     -         lda #DOT
126d: a0 00     -         ldy #0
126f: 91 fb     -         sta (ZP1),y
1271: a6 0a     -         ldx GLOBAL_X										//restore x
1273: e8        -         inx													//next room
1274: e0 04     -         cpx #ROOM_NUMBER
1276: f0 03     -         beq out
1278: 4c 25 11  -         jmp each
127b: 60        - out:    rts
127c: a2 03     - CHECK_CONNECTION:ldx #03						//iterate over directions
127e: 8a        - each:   txa
127f: 0a        -         asl
1280: a8        -         tay							//offset in y
1281: a5 50     -         lda BV7
1283: 18        -         clc
1284: 79 ab 09  -         adc BASIC_DIRS,y
1287: 85 4e     -         sta BV9						//test.x
1289: c8        -         iny
128a: a5 51     -         lda BV8
128c: 18        -         clc
128d: 79 ab 09  -         adc BASIC_DIRS,y
1290: 85 4f     -         sta BV10					//test.y
1292: ad b6 13  -         lda X
1295: 85 fb     -         sta Y
1297: ad b7 13  -         lda X + 1
129a: 85 fc     -         sta Y + 1
129c: a9 00     -         lda #0
129e: 85 fe     -         sta ZP4				
12a0: a5 4f     -         lda grid+1		
12a2: 85 fd     -         sta ZP3
12a4: a0 03     -         ldy #03
12a6: 06 fd     - mul8:   asl X
12a8: 26 fe     -         rol X+1	
12aa: 88        -         dey
12ab: d0 f9     -         bne mul8
12ad: 18        -         clc
12ae: a5 fb     -         lda X
12b0: 65 fd     -         adc Y
12b2: 85 fb     -         sta X
12b4: 90 02     -         bcc skip
12b6: e6 fc     -         inc X+1
12b8: 18        - skip:   clc
12b9: a5 fc     -         lda X+1
12bb: 65 fe     -         adc Y+1
12bd: 85 fc     -         sta X+1	
12bf: a0 02     -         ldy #02	
12c1: 06 fd     - mul32:  asl X
12c3: 26 fe     -         rol X+1	
12c5: 88        -         dey
12c6: d0 f9     -         bne mul32
12c8: 18        -         clc
12c9: a5 fb     -         lda X
12cb: 65 fd     -         adc Y
12cd: 85 fb     -         sta X
12cf: 90 02     -         bcc skip
12d1: e6 fc     -         inc X+1
12d3: 18        - skip:   clc
12d4: a5 fc     -         lda X+1
12d6: 65 fe     -         adc Y+1
12d8: 85 fc     -         sta X+1	
12da: 18        -         clc
12db: a5 fb     -         lda X
12dd: 65 4e     -         adc y	
12df: 85 fb     -         sta X
12e1: 90 02     -         bcc out+2
12e3: e6 fc     - out:    inc X+1
12e5: a0 00     -         ldy #0
12e7: b1 fb     -         lda (ZP1),y
12e9: c9 20     -         cmp #DOT
12eb: d0 02     -         bne skip
12ed: e6 4a     -         inc VAR_D
12ef: ca        - skip:   dex
12f0: 10 8c     -         bpl each
12f2: 60        - out:    rts
12f3: 20 fb 0e  - MAZE:   jsr STORE_DEAD_END
12f6: 20 d6 09  - outer,P_LOOP:jsr MAZE_DOT
12f9: 20 89 0a  -         jsr POINTERS_FROM_START
12fc: 20 c1 0a  -         jsr FILTER_IF_OUT
12ff: 20 24 0b  -         jsr FILTER_IF_DOT
1302: a9 20     -         lda #test
1304: 85 52     -         sta BV0
1306: 20 46 0c  -         jsr FILTER_IF_NEXT_PRIMARY
1309: 20 8c 0d  -         jsr FILTER_SIDE_PROXIMIY
130c: ad d0 13  -         lda candidates_length						//check how many we have
130f: c9 00     -         cmp #00										//if zero break;
1311: d0 06     -         bne more									//more than 0
1313: 20 fb 0e  -         jsr STORE_DEAD_END							//store dead end
1316: 4c 83 13  -         jmp S_LOOP
1319: c9 02     - more:   cmp #02										//if it is two or more
131b: b0 05     -         bcs then									//go to else/then
131d: a9 00     -         lda #0										//otherwise, index->0 in A									
131f: 4c 49 13  -         jmp skip_else
1322: ad da 13  - then:   lda bias_counter
1325: c9 00     -         cmp #00
1327: f0 07     -         beq select_random							//use random, not bias
1329: 20 db 0e  -         jsr CHECK_BIAS								//index in a, or -1 if not found
132c: c9 ff     -         cmp #-1
132e: d0 19     -         bne skip_else								//not -1, select this direction
1330: a9 00     - select_random:lda #0										//reset bias counter when selection is random	
1332: 8d da 13  -         sta bias_counter
1335: ad d0 13  -         lda candidates_length						//random index (, candidates length-1)
1338: aa        -         tax
1339: ca        -         dex
133a: 86 02     -         stx ZP0
133c: a5 02     -         lda X	
133e: 85 fd     -         sta ZP3
1340: a9 00     -         lda #0
1342: 85 fe     -         sta ZP4
1344: 20 7b 09  -         jsr rnd_X
1347: a5 14     -         lda WINT
1349: 85 02     - skip_else:sta ZP0										//store index in ZP0	
134b: 0a        -         asl 										//datasize=2	
134c: a8        -         tay											//offset in y
134d: b9 c0 13  -         lda candidates,y
1350: 8d b8 13  -         sta maze_start
1353: b9 c8 13  -         lda candidates_vectors,y
1356: 8d db 13  -         sta bias_direction
1359: c8        -         iny
135a: b9 c0 13  -         lda candidates,y
135d: 8d b9 13  -         sta maze_start+1
1360: b9 c8 13  -         lda candidates_vectors,y
1363: 8d dc 13  -         sta bias_direction+1
1366: ee da 13  -         inc bias_counter
1369: ad da 13  -         lda bias_counter
136c: cd d9 13  -         cmp bias
136f: d0 05     -         bne out+3
1371: a9 00     -         lda #00
1373: 8d da 13  - out:    sta bias_counter
1376: ad d0 13  -         lda candidates_length
1379: c9 02     -         cmp #02										//if there are 2 or more, selected has not been discarded yet
137b: 90 03     -         bcc repeat_P								//no, repeat loop
137d: 20 d5 0b  -         jsr PUSH_REST_ON_STACK													
1380: 4c f6 12  - repeat_P:jmp P_LOOP
1383: a5 71     - S_LOOP: lda STKPTR1
1385: c9 00     -         cmp #<STACK
1387: d0 09     -         bne cont
1389: a5 72     -         lda STKPTR2
138b: c9 c0     -         cmp #>STACK
138d: d0 03     -         bne cont
138f: 4c b5 13  -         jmp quit									//stack pointer == STACK, stack is empty
1392: 20 a5 0e  - cont:   jsr CANDIDATE_FROM_STACK					//take on grid an its direction from stack
1395: a9 20     -         lda #test
1397: 85 52     -         sta BV0
1399: 20 46 0c  -         jsr FILTER_IF_NEXT_PRIMARY
139c: 20 8c 0d  -         jsr FILTER_SIDE_PROXIMIY					//in terms of proximity
139f: ad d0 13  -         lda candidates_length						//check if it is still ok
13a2: c9 00     -         cmp #00										//if zero break; 
13a4: f0 dd     -         beq S_LOOP									//no, find another
13a6: ad c0 13  -         lda candidates								//set it to maze_start
13a9: 8d b8 13  -         sta maze_start
13ac: ad c1 13  -         lda candidates+1
13af: 8d b9 13  -         sta maze_start+1
13b2: 4c f6 12  -         jmp P_LOOP									//make next branch
13b5: 60        - quit:   rts

[MAZE Memory]
13b6: 04 00     - MAZE_memory,maze_memory_alloc:.word $0004 					//screen by default
13b8: 00 00     - maze_start:.word 0
13ba: 00 00     - grid_pointer:.word 0
13bc: 00 00     - direction_pointer:.word 0
13be: 00 00     - test_pointer:.word 0
13c0: 00 00     - candidates:.fill 2,0
13c2: 00 00     -         .fill 2,0
13c4: 00 00     -         .fill 2,0
13c6: 00 00     -         .fill 2,0
13c8: 00 00     - candidates_vectors:.fill 2,0
13ca: 00 00     -         .fill 2,0
13cc: 00 00     -         .fill 2,0
13ce: 00 00     -         .fill 2,0
13d0: 00        - candidates_length:.byte 0
13d1: 00 00     - proximity_vectors:.fill 2,0
13d3: 00 00     -         .fill 2,0
13d5: 00 00     -         .fill 2,0
13d7: 00 00     -         .fill 2,0
13d9: 02        - bias:   .byte 2
13da: 00        - bias_counter:.byte 0
13db: 00 00     - bias_direction:.word 0
13dd: 00        - DE_counter:.byte 0
13de: 00        - REM_DE_counter:.byte 0
13df: 00 00 00 00                                      - rooms:  .fill 4,0
13e3: 00 00 00 00                                      -         .fill 4,0
13e7: 00 00 00 00                                      -         .fill 4,0
13eb: 00 00 00 00                                      -         .fill 4,0
13ef: 03 0e 03 06                                      - room_def:.byte 3, 14, 3, 6
13f3: 17 21 03 06                                      -         .byte 23, 33, 3, 6
13f7: 03 0e 0e 11                                      -         .byte 3, 14, 14, 17
13fb: 17 21 0e 11                                      -         .byte 23, 33, 14, 17
13ff: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - exit_candidates:.fill MAX_W * 4 * 2, 0
140f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
141f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - exit_candidate_dirs:.fill MAX_W * 4 * 2, 0
142f: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
143f: 00        - exit_candidates_length:.byte 0

[Subroutines]
1440: ad 83 14  - subs,irqcode:lda modeflag
1443: f0 03     -         beq mode1
1445: 4c 5d 14  -         jmp mode2
1448: a9 01     - mode1:  lda #$01
144a: 8d 83 14  -         sta modeflag
144d: a9 00     -         lda #BLACK
144f: 8d 20 d0  -         sta BORDER
1452: a9 32     -         lda #startRaster
1454: 8d 12 d0  -         sta RASTER_COUNTER
1457: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
145a: 4c 31 ea  -         jmp IRQOUT
145d: a9 00     - mode2:  lda #$00
145f: 8d 83 14  -         sta modeflag
1462: a9 0f     -         lda #LIGHTGREY
1464: 8d 20 d0  -         sta BORDER
1467: a9 fa     -         lda #endRaster
1469: 8d 12 d0  -         sta RASTER_COUNTER
146c: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
146f: 68        -         pla
1470: a8        -         tay
1471: 68        -         pla
1472: aa        -         tax
1473: 68        -         pla
1474: 40        -         rti
1475: a2 00     - set_bricks:ldx #00
1477: bd 86 14  - copy:   lda brick_data,x
147a: 9d 00 30  -         sta char_offset,x
147d: e8        -         inx
147e: e0 08     -         cpx #08
1480: d0 f5     -         bne copy
1482: 60        -         rts

[Data]
1483: 00        - text,data,modeflag:.byte 0
1484: 00        - startX: .byte 0
1485: 00        - startY: .byte 0
1486: dd c1 38 bb bb 83 1c dd                          - brick_data:.byte $dd,$c1,$38,$bb,$bb,$83,$1c,$dd
