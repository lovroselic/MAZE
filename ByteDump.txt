******************************* Segment: Default *******************************
[Header]
0801: 0c 08     -         .word bend
0803: 0d 00     -         .byte $0d, $00				//;line number
0805: 9e        -         .byte $9E					//;SYS
0806: 20        -         .byte $20					//;space
0807: 32 30 36 34                                      -         .byte $32,$30,$36,$34		//;start 2064
080b: 00        -         .byte $00					//;end of line
080c: 00 00     - bend:   .byte $00, $00				//;end of basic program

[Main]
0810: 20 1f 09  - setup:  jsr COPY_CHAR_ROM_TO_RAM
0813: 20 58 0f  -         jsr set_bricks
0816: a9 0f     -         lda	#color
0818: a0 00     -         ldy #0
081a: 99 00 d8  - fill:   sta COLOR_RAM,y
081d: 99 00 d9  -         sta COLOR_RAM + 256,y
0820: 99 00 da  -         sta COLOR_RAM + 512,y
0823: 99 00 db  -         sta COLOR_RAM + 768,y
0826: c8        -         iny
0827: d0 f1     -         bne fill
0829: a9 00     -         lda #BLACK
082b: 8d 21 d0  -         sta BACKGROUND
082e: 78        - interrupt:sei							//set interrupt
082f: a9 7f     -         lda #$7f
0831: 8d 0d dc  -         sta CIA_ICR
0834: 8d 0d dd  -         sta CIA2_ICR
0837: ad 0d dc  -         lda CIA_ICR
083a: ad 0d dd  -         lda CIA2_ICR
083d: ad 1a d0  -         lda INTERRUPT_MASK_REGISTER	
0840: 09 01     -         ora #$01
0842: 8d 1a d0  -         sta INTERRUPT_MASK_REGISTER
0845: ad 11 d0  -         lda CONTROL_REGISTER1
0848: 29 7f     -         and #$7f
084a: 8d 11 d0  -         sta CONTROL_REGISTER1
084d: a9 32     -         lda #startRaster
084f: 8d 12 d0  -         sta RASTER_COUNTER
0852: a9 23     -         lda #<address
0854: 8d 14 03  -         sta IRQVEC
0857: a9 0f     -         lda #>address
0859: 8d 15 03  -         sta	IRQVEC+1
085c: 58        -         cli
085d: d8        - begin:  cld
085e: a9 02     - init:   lda #B
0860: 8d 1f 0f  -         sta bias
0863: a9 00     -         lda #00
0865: 8d 20 0f  -         sta bias_counter
0868: a9 26     -         lda #<end	
086a: 85 fd     -         sta ZP3
086c: a9 00     -         lda #>end
086e: 85 fe     -         sta ZP4
0870: a9 01     -         lda #<start
0872: 85 fb     -         sta ZP1
0874: a9 00     -         lda #>start
0876: 85 fc     -         sta ZP2
0878: 20 4f 09  -         jsr rnd_XY
087b: a5 14     -         lda X
087d: 8d 67 0f  -         sta Y
0880: a9 17     -         lda #<end	
0882: 85 fd     -         sta ZP3
0884: a9 00     -         lda #>end
0886: 85 fe     -         sta ZP4
0888: a9 01     -         lda #<start
088a: 85 fb     -         sta ZP1
088c: a9 00     -         lda #>start
088e: 85 fc     -         sta ZP2
0890: 20 4f 09  -         jsr rnd_XY
0893: a5 14     -         lda X
0895: 8d 68 0f  -         sta Y
0898: a9 00     -         lda #<addr
089a: 8d fc 0e  -         sta X
089d: a9 04     -         lda #>addr
089f: 8d fd 0e  -         sta X+1
08a2: ad 67 0f  -         lda X
08a5: 8d fe 0e  -         sta Y
08a8: ad 68 0f  -         lda X + 1
08ab: 8d ff 0e  -         sta Y + 1
08ae: a9 00     -         lda #<addr
08b0: 85 71     -         sta X
08b2: a9 c0     -         lda #>addr
08b4: 85 72     -         sta X+1
08b6: 20 47 0e  -         jsr MAZE
08b9: a5 c5     - end,key:lda LSTX		//get character in A
08bb: c9 40     -         cmp #64			//no key
08bd: f0 fa     -         beq key
08bf: 4c 5e 08  -         jmp init
08c2: 60        -         rts

[Imports]
08c3: c6 48     - imports,SPLICE:dec VAR_B								//array length - 1, last index
08c5: a4 47     -         ldy VAR_A								//index
08c7: c4 48     - loop:   cpy VAR_B								//stop if index
08c9: 10 35     -         bpl out 								//equal or greater than last index
08cb: a2 00     -         ldx #0									//number of properties (data_size), start from 0
08cd: c8        - each:   iny		
08ce: 84 40     -         sty TEMPY
08d0: a5 49     -         lda	VAR_C 								//data size
08d2: 20 01 09  -         jsr MUL_Y_A
08d5: 84 02     -         sty ZP0
08d7: 8a        -         txa
08d8: 18        -         clc
08d9: 65 02     -         adc ZP0
08db: a8        -         tay
08dc: b1 43     -         lda (BV1),y
08de: 85 41     -         sta TEMPA1
08e0: a4 40     -         ldy TEMPY
08e2: 88        -         dey
08e3: 84 40     -         sty TEMPY
08e5: a5 49     -         lda	VAR_C 								//data size
08e7: 20 01 09  -         jsr MUL_Y_A
08ea: 84 02     -         sty ZP0
08ec: 8a        -         txa
08ed: 18        -         clc
08ee: 65 02     -         adc ZP0
08f0: a8        -         tay
08f1: a5 41     -         lda TEMPA1
08f3: 91 43     -         sta (BV1),y
08f5: a4 40     -         ldy TEMPY
08f7: e8        -         inx
08f8: e4 49     -         cpx VAR_C								//all props? less than VAR_C ?
08fa: 90 d1     -         bcc each
08fc: c8        -         iny
08fd: 4c c7 08  -         jmp loop
0900: 60        - out:    rts
0901: c0 00     - MUL_Y_A,multiply:cpy #00
0903: f0 18     -         beq end
0905: 88        -         dey
0906: 8c 13 09  -         sty mod+1
0909: 4a        -         lsr
090a: 85 02     -         sta ZP0
090c: a9 00     -         lda #00
090e: a0 08     -         ldy #$08
0910: 90 02     - loop:   bcc skip
0912: 69 00     - mod:    adc #0
0914: 6a        - skip:   ror
0915: 66 02     -         ror ZP0
0917: 88        -         dey
0918: d0 f6     -         bne loop
091a: a4 02     -         ldy ZP0
091c: 60        -         rts
091d: 98        - end:    tya
091e: 60        -         rts
091f: 78        - COPY_CHAR_ROM_TO_RAM:sei
0920: a5 01     -         lda $01			//make ROM visible
0922: 29 fb     -         and #$FB
0924: 85 01     -         sta $01 
0926: a9 00     -         lda #00
0928: 85 5f     -         sta $5f			//block start
092a: 85 5a     -         sta $5a			//block end
092c: 85 58     -         sta $58			//destination end
092e: a0 d0     -         ldy #$d0
0930: 84 60     -         sty $60			//block start
0932: a0 e0     -         ldy #$e0		
0934: 84 5b     -         sty $5b			//block end
0936: a0 40     - ram:    ldy #$40
0938: 84 59     -         sty $59			//destination end
093a: 20 bf a3  -         jsr MOVE_BYTES
093d: a5 01     -         lda $01			//hide rom
093f: 09 04     -         ora #$04
0941: 85 01     -         sta $01
0943: 58        -         cli
0944: ad 18 d0  -         lda VMCSB
0947: 29 f0     -         and #%11110000
0949: 09 0c     -         ora #%00001100	//$3000
094b: 8d 18 d0  -         sta VMCSB
094e: 60        -         rts

[SYSTEM_data]
094f: e6 fd     - SYS_data,rnd_XY:inc ZP3
0951: d0 02     -         bne skip1
0953: e6 fe     -         inc ZP4
0955: a5 fd     - skip1:  lda ZP3
0957: 38        -         sec
0958: e5 fb     -         sbc ZP1
095a: 85 fd     -         sta ZP3
095c: a5 fe     -         lda ZP4
095e: e5 fc     -         sbc ZP2
0960: 85 fe     -         sta ZP4			
0962: a4 fd     - toFloat:ldy ZP3
0964: a5 fe     -         lda ZP4
0966: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
0969: a2 bb     -         ldx #<flt
096b: a0 09     -         ldy #>flt
096d: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
0970: a9 00     -         lda #$00					//RND(0)
0972: 20 9a e0  -         jsr RND						//$E09A
0975: a9 bb     -         lda #<flt
0977: a0 09     -         ldy #>flt
0979: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
097c: 20 cc bc  -         jsr FAINT					//to integer
097f: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
0982: a5 65     -         lda $65						//FAC mantissa lo
0984: 18        -         clc
0985: 65 fb     -         adc ZP1						//add number to start	
0987: 85 14     -         sta WINT
0989: a5 64     -         lda $64						//FAC mantissa hi
098b: 65 fc     -         adc ZP2
098d: 85 15     -         sta WINT+1
098f: 60        - over:   rts			
0990: e6 fd     - rnd_X:  inc ZP3
0992: d0 02     -         bne toFloat
0994: e6 fe     -         inc ZP4	
0996: a4 fd     - toFloat:ldy ZP3
0998: a5 fe     -         lda ZP4
099a: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
099d: a2 bb     -         ldx #<flt
099f: a0 09     -         ldy #>flt
09a1: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
09a4: a9 00     -         lda #$00					//get actual RND(0)
09a6: 20 9a e0  -         jsr RND						//$E09A
09a9: a9 bb     -         lda #<flt
09ab: a0 09     -         ldy #>flt
09ad: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
09b0: 20 cc bc  -         jsr FAINT					//to integer
09b3: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
09b6: a5 65     -         lda $65						//FAC mantissa lo
09b8: 85 14     -         sta WINT					
09ba: 60        -         rts			

[Data RND]
09bb: 00 00 00 00 00                                   - dataRND,flt:.byte 0,0,0,0,0

[Grid_Constants]
09c0: 00 ff     - Grid_Constants,BASIC_DIRS,UP:.byte 	0, -1
09c2: 00 01     - DOWN:   .byte 	0, 1
09c4: ff 00     - LEFT:   .byte	-1, 0
09c6: 01 00     - RIGHT:  .byte 	1,0
09c8: ff ff     - PROX_TEMPLATE:.byte 	-1, -1
09ca: 01 01     -         .byte 	1, 1
09cc: ff ff     -         .byte 	-1, -1
09ce: 01 01     -         .byte 	1, 1
09d0: ad fc 0e  - MAZE_FILL:lda X
09d3: 85 fb     -         sta Y
09d5: ad fd 0e  -         lda X + 1
09d8: 85 fc     -         sta Y + 1
09da: a9 00     -         lda	#WALL
09dc: a2 04     -         ldx #4
09de: a0 00     - block:  ldy #0
09e0: 91 fb     - fill:   sta (ZP1),y
09e2: c8        -         iny
09e3: d0 fb     -         bne fill
09e5: e6 fc     -         inc ZP2
09e7: ca        -         dex
09e8: d0 f4     -         bne block
09ea: 60        -         rts
09eb: ad fc 0e  - MAZE_DOT:lda X
09ee: 85 fb     -         sta Y
09f0: ad fd 0e  -         lda X + 1
09f3: 85 fc     -         sta Y + 1
09f5: a9 00     -         lda #0
09f7: 85 fe     -         sta ZP4				
09f9: ad ff 0e  -         lda grid+1		
09fc: 85 fd     -         sta ZP3
09fe: a0 03     -         ldy #03
0a00: 06 fd     - mul8:   asl X
0a02: 26 fe     -         rol X+1	
0a04: 88        -         dey
0a05: d0 f9     -         bne mul8
0a07: 18        -         clc
0a08: a5 fb     -         lda X
0a0a: 65 fd     -         adc Y
0a0c: 85 fb     -         sta X
0a0e: 90 02     -         bcc skip
0a10: e6 fc     -         inc X+1
0a12: 18        - skip:   clc
0a13: a5 fc     -         lda X+1
0a15: 65 fe     -         adc Y+1
0a17: 85 fc     -         sta X+1	
0a19: a0 02     -         ldy #02	
0a1b: 06 fd     - mul32:  asl X
0a1d: 26 fe     -         rol X+1	
0a1f: 88        -         dey
0a20: d0 f9     -         bne mul32
0a22: 18        -         clc
0a23: a5 fb     -         lda X
0a25: 65 fd     -         adc Y
0a27: 85 fb     -         sta X
0a29: 90 02     -         bcc skip
0a2b: e6 fc     -         inc X+1
0a2d: 18        - skip:   clc
0a2e: a5 fc     -         lda X+1
0a30: 65 fe     -         adc Y+1
0a32: 85 fc     -         sta X+1	
0a34: 18        -         clc
0a35: a5 fb     -         lda X
0a37: 6d fe 0e  -         adc y	
0a3a: 85 fb     -         sta X
0a3c: 90 02     -         bcc out+2
0a3e: e6 fc     - out:    inc X+1
0a40: a9 20     -         lda #DOT
0a42: a0 00     -         ldy #0
0a44: 91 fb     -         sta (ZP1),y
0a46: 60        -         rts
0a47: a2 03     - POINTERS_FROM_START:ldx #03
0a49: 8a        - add:    txa
0a4a: 0a        -         asl
0a4b: a8        -         tay		
0a4c: 18        -         clc
0a4d: ad fe 0e  -         lda maze_start
0a50: 79 c0 09  -         adc BASIC_DIRS,y
0a53: 99 06 0f  -         sta candidates,y
0a56: c8        -         iny
0a57: 18        -         clc
0a58: ad ff 0e  -         lda maze_start+1
0a5b: 79 c0 09  -         adc BASIC_DIRS,y
0a5e: 99 06 0f  -         sta candidates,y
0a61: ca        -         dex
0a62: 10 e5     -         bpl add
0a64: a2 03     -         ldx #03
0a66: 8a        - copy:   txa
0a67: 0a        -         asl
0a68: a8        -         tay	
0a69: b9 c0 09  -         lda BASIC_DIRS,y
0a6c: 99 0e 0f  -         sta candidates_vectors,y
0a6f: c8        -         iny
0a70: b9 c0 09  -         lda BASIC_DIRS,y
0a73: 99 0e 0f  -         sta candidates_vectors,y
0a76: ca        -         dex
0a77: 10 ed     -         bpl copy
0a79: a9 04     -         lda #04
0a7b: 8d 16 0f  -         sta candidates_length
0a7e: 60        -         rts
0a7f: ad 16 0f  - FILTER_IF_OUT:lda candidates_length
0a82: c9 01     -         cmp #1
0a84: b0 01     -         bcs start
0a86: 60        -         rts
0a87: ae 16 0f  - start:  ldx candidates_length				//number of grids yet to check
0a8a: ca        -         dex
0a8b: 8a        - each:   txa
0a8c: 0a        -         asl
0a8d: a8        -         tay
0a8e: 18        -         clc
0a8f: b9 06 0f  -         lda candidates,y
0a92: c9 27     -         cmp #MAX_X+1
0a94: b0 18     -         bcs shift
0a96: c9 01     -         cmp #MIN_X
0a98: 90 14     -         bcc shift
0a9a: c8        -         iny
0a9b: 18        -         clc
0a9c: b9 06 0f  -         lda candidates,y
0a9f: c9 18     -         cmp #MAX_Y+1
0aa1: b0 0b     -         bcs shift
0aa3: c9 01     -         cmp #MIN_Y
0aa5: 90 07     -         bcc shift
0aa7: ca        - cont:   dex
0aa8: 30 03     -         bmi out
0aaa: 4c 8b 0a  -         jmp each
0aad: 60        - out:    rts
0aae: 86 3f     - shift:  stx TEMPX									//save x							
0ab0: 86 47     -         stx VAR_A									//set index to VAR_A
0ab2: ad 16 0f  -         lda X
0ab5: 85 48     -         sta Y
0ab7: a9 06     -         lda #<addr
0ab9: 85 43     -         sta X
0abb: a9 0f     -         lda #>addr
0abd: 85 44     -         sta X+1
0abf: a9 02     -         lda #data_size
0ac1: 85 49     -         sta VAR_C
0ac3: 20 c3 08  -         jsr SPLICE
0ac6: ad 16 0f  -         lda X
0ac9: 85 48     -         sta Y
0acb: a9 0e     -         lda #<addr
0acd: 85 43     -         sta X
0acf: a9 0f     -         lda #>addr
0ad1: 85 44     -         sta X+1
0ad3: a9 02     -         lda #data_size
0ad5: 85 49     -         sta VAR_C
0ad7: 20 c3 08  -         jsr SPLICE
0ada: ce 16 0f  -         dec candidates_length						//dec array length
0add: a6 3f     -         ldx TEMPX									//restore x
0adf: 4c a7 0a  -         jmp cont									//return to loop
0ae2: ad 16 0f  - FILTER_IF_DOT:lda candidates_length
0ae5: c9 01     -         cmp #1
0ae7: b0 01     -         bcs start
0ae9: 60        -         rts
0aea: ae 16 0f  - start:  ldx candidates_length						//number of grids yet to check
0aed: ca        -         dex
0aee: 8a        - each:   txa
0aef: 0a        -         asl
0af0: a8        -         tay
0af1: b9 06 0f  -         lda candidates,y
0af4: 8d 00 0f  -         sta grid_pointer
0af7: c8        -         iny
0af8: b9 06 0f  -         lda candidates,y
0afb: 8d 01 0f  -         sta grid_pointer+1
0afe: ad fc 0e  -         lda X
0b01: 85 fb     -         sta Y
0b03: ad fd 0e  -         lda X + 1
0b06: 85 fc     -         sta Y + 1
0b08: a9 00     -         lda #0
0b0a: 85 fe     -         sta ZP4				
0b0c: ad 01 0f  -         lda grid+1		
0b0f: 85 fd     -         sta ZP3
0b11: a0 03     -         ldy #03
0b13: 06 fd     - mul8:   asl X
0b15: 26 fe     -         rol X+1	
0b17: 88        -         dey
0b18: d0 f9     -         bne mul8
0b1a: 18        -         clc
0b1b: a5 fb     -         lda X
0b1d: 65 fd     -         adc Y
0b1f: 85 fb     -         sta X
0b21: 90 02     -         bcc skip
0b23: e6 fc     -         inc X+1
0b25: 18        - skip:   clc
0b26: a5 fc     -         lda X+1
0b28: 65 fe     -         adc Y+1
0b2a: 85 fc     -         sta X+1	
0b2c: a0 02     -         ldy #02	
0b2e: 06 fd     - mul32:  asl X
0b30: 26 fe     -         rol X+1	
0b32: 88        -         dey
0b33: d0 f9     -         bne mul32
0b35: 18        -         clc
0b36: a5 fb     -         lda X
0b38: 65 fd     -         adc Y
0b3a: 85 fb     -         sta X
0b3c: 90 02     -         bcc skip
0b3e: e6 fc     -         inc X+1
0b40: 18        - skip:   clc
0b41: a5 fc     -         lda X+1
0b43: 65 fe     -         adc Y+1
0b45: 85 fc     -         sta X+1	
0b47: 18        -         clc
0b48: a5 fb     -         lda X
0b4a: 6d 00 0f  -         adc y	
0b4d: 85 fb     -         sta X
0b4f: 90 02     -         bcc out+2
0b51: e6 fc     - out:    inc X+1
0b53: a0 00     -         ldy #0
0b55: b1 fb     -         lda (ZP1),y
0b57: c9 20     -         cmp #DOT
0b59: f0 04     -         beq shift
0b5b: ca        - cont:   dex
0b5c: 10 90     -         bpl each
0b5e: 60        - out:    rts
0b5f: 86 3f     - shift:  stx TEMPX									//save x
0b61: 86 47     -         stx VAR_A									//set index to VAR_A
0b63: ad 16 0f  -         lda X
0b66: 85 48     -         sta Y
0b68: a9 06     -         lda #<addr
0b6a: 85 43     -         sta X
0b6c: a9 0f     -         lda #>addr
0b6e: 85 44     -         sta X+1
0b70: a9 02     -         lda #data_size
0b72: 85 49     -         sta VAR_C
0b74: 20 c3 08  -         jsr SPLICE
0b77: ad 16 0f  -         lda X
0b7a: 85 48     -         sta Y
0b7c: a9 0e     -         lda #<addr
0b7e: 85 43     -         sta X
0b80: a9 0f     -         lda #>addr
0b82: 85 44     -         sta X+1
0b84: a9 02     -         lda #data_size
0b86: 85 49     -         sta VAR_C
0b88: 20 c3 08  -         jsr SPLICE
0b8b: ce 16 0f  -         dec candidates_length						//dec array length
0b8e: a6 3f     -         ldx TEMPX									//restore x
0b90: 4c 5b 0b  -         jmp cont									//return to loop
0b93: a5 02     - PUSH_REST_ON_STACK:lda ZP0										//index was stored in ZP0
0b95: 85 47     -         sta VAR_A									//set index to VAR_A
0b97: ad 16 0f  -         lda X
0b9a: 85 48     -         sta Y
0b9c: a9 06     -         lda #<addr
0b9e: 85 43     -         sta X
0ba0: a9 0f     -         lda #>addr
0ba2: 85 44     -         sta X+1
0ba4: a9 02     -         lda #data_size
0ba6: 85 49     -         sta VAR_C
0ba8: 20 c3 08  -         jsr SPLICE
0bab: ad 16 0f  -         lda X
0bae: 85 48     -         sta Y
0bb0: a9 0e     -         lda #<addr
0bb2: 85 43     -         sta X
0bb4: a9 0f     -         lda #>addr
0bb6: 85 44     -         sta X+1
0bb8: a9 02     -         lda #data_size
0bba: 85 49     -         sta VAR_C
0bbc: 20 c3 08  -         jsr SPLICE
0bbf: ce 16 0f  -         dec candidates_length						//dec array length
0bc2: a2 00     -         ldx #0
0bc4: a0 00     - each:   ldy #0
0bc6: 86 3f     -         stx TEMPX									//save x
0bc8: 8a        -         txa											//x = x *2	
0bc9: 0a        -         asl 
0bca: aa        -         tax									
0bcb: bd 06 0f  -         lda candidates,x							//x
0bce: 91 71     -         sta (STKPTR1),y
0bd0: c8        -         iny
0bd1: e8        -         inx
0bd2: bd 06 0f  -         lda candidates,x							//y
0bd5: 91 71     -         sta (STKPTR1),y
0bd7: 18        -         clc
0bd8: a5 71     -         lda X
0bda: 69 02     -         adc #C
0bdc: 85 71     -         sta X
0bde: 90 02     -         bcc out+2
0be0: e6 72     - out:    inc X+1
0be2: 88        -         dey
0be3: ca        -         dex
0be4: bd 0e 0f  -         lda candidates_vectors,x					//x
0be7: 91 71     -         sta (STKPTR1),y
0be9: c8        -         iny
0bea: e8        -         inx
0beb: bd 0e 0f  -         lda candidates_vectors,x					//y
0bee: 91 71     -         sta (STKPTR1),y
0bf0: 18        -         clc
0bf1: a5 71     -         lda X
0bf3: 69 02     -         adc #C
0bf5: 85 71     -         sta X
0bf7: 90 02     -         bcc out+2
0bf9: e6 72     - out:    inc X+1
0bfb: a6 3f     -         ldx TEMPX									//restore x
0bfd: e8        -         inx
0bfe: ec 16 0f  -         cpx candidates_length
0c01: d0 c1     -         bne each
0c03: 60        - out:    rts		
0c04: ad 16 0f  - FILTER_IF_CLOSE_PRIMARY:lda candidates_length
0c07: c9 01     -         cmp #1
0c09: b0 01     -         bcs start										//cont if 1 or more
0c0b: 60        -         rts												//else exit, if no candidates
0c0c: ae 16 0f  - start:  ldx candidates_length							//number of grids yet to check
0c0f: ca        -         dex												//to zero offset
0c10: 8a        - each:   txa
0c11: 0a        -         asl												//double, because datasize is 2
0c12: a8        -         tay												//offset in y (zero based x * datasize)
0c13: b9 06 0f  -         lda candidates,y
0c16: 8d 00 0f  -         sta grid_pointer
0c19: b9 0e 0f  -         lda candidates_vectors,y
0c1c: 8d 02 0f  -         sta direction_pointer
0c1f: c8        -         iny
0c20: b9 06 0f  -         lda candidates,y
0c23: 8d 01 0f  -         sta grid_pointer+1
0c26: b9 0e 0f  -         lda candidates_vectors,y
0c29: 8d 03 0f  -         sta direction_pointer+1
0c2c: 18        -         clc
0c2d: ad 00 0f  -         lda grid_pointer
0c30: 6d 02 0f  -         adc direction_pointer
0c33: 8d 04 0f  -         sta test_pointer
0c36: 18        -         clc
0c37: ad 01 0f  -         lda grid_pointer+1
0c3a: 6d 03 0f  -         adc direction_pointer+1
0c3d: 8d 05 0f  -         sta test_pointer+1
0c40: ad fc 0e  -         lda X
0c43: 85 fb     -         sta Y
0c45: ad fd 0e  -         lda X + 1
0c48: 85 fc     -         sta Y + 1
0c4a: a9 00     -         lda #0
0c4c: 85 fe     -         sta ZP4				
0c4e: ad 05 0f  -         lda grid+1		
0c51: 85 fd     -         sta ZP3
0c53: a0 03     -         ldy #03
0c55: 06 fd     - mul8:   asl X
0c57: 26 fe     -         rol X+1	
0c59: 88        -         dey
0c5a: d0 f9     -         bne mul8
0c5c: 18        -         clc
0c5d: a5 fb     -         lda X
0c5f: 65 fd     -         adc Y
0c61: 85 fb     -         sta X
0c63: 90 02     -         bcc skip
0c65: e6 fc     -         inc X+1
0c67: 18        - skip:   clc
0c68: a5 fc     -         lda X+1
0c6a: 65 fe     -         adc Y+1
0c6c: 85 fc     -         sta X+1	
0c6e: a0 02     -         ldy #02	
0c70: 06 fd     - mul32:  asl X
0c72: 26 fe     -         rol X+1	
0c74: 88        -         dey
0c75: d0 f9     -         bne mul32
0c77: 18        -         clc
0c78: a5 fb     -         lda X
0c7a: 65 fd     -         adc Y
0c7c: 85 fb     -         sta X
0c7e: 90 02     -         bcc skip
0c80: e6 fc     -         inc X+1
0c82: 18        - skip:   clc
0c83: a5 fc     -         lda X+1
0c85: 65 fe     -         adc Y+1
0c87: 85 fc     -         sta X+1	
0c89: 18        -         clc
0c8a: a5 fb     -         lda X
0c8c: 6d 04 0f  -         adc y	
0c8f: 85 fb     -         sta X
0c91: 90 02     -         bcc out+2
0c93: e6 fc     - out:    inc X+1
0c95: a0 00     -         ldy #0
0c97: b1 fb     -         lda (ZP1),y
0c99: c9 20     -         cmp #DOT									//is dot? (empty)
0c9b: f0 07     -         beq shift									//yes
0c9d: ca        - cont:   dex
0c9e: 30 03     -         bmi out										//less than zero, stop
0ca0: 4c 10 0c  -         jmp each									//loop back, branch too far
0ca3: 60        - out:    rts
0ca4: 86 3f     - shift:  stx TEMPX									//save x
0ca6: 86 47     -         stx VAR_A									//set index to VAR_A
0ca8: ad 16 0f  -         lda X
0cab: 85 48     -         sta Y
0cad: a9 06     -         lda #<addr
0caf: 85 43     -         sta X
0cb1: a9 0f     -         lda #>addr
0cb3: 85 44     -         sta X+1
0cb5: a9 02     -         lda #data_size
0cb7: 85 49     -         sta VAR_C
0cb9: 20 c3 08  -         jsr SPLICE
0cbc: ad 16 0f  -         lda X
0cbf: 85 48     -         sta Y
0cc1: a9 0e     -         lda #<addr
0cc3: 85 43     -         sta X
0cc5: a9 0f     -         lda #>addr
0cc7: 85 44     -         sta X+1
0cc9: a9 02     -         lda #data_size
0ccb: 85 49     -         sta VAR_C
0ccd: 20 c3 08  -         jsr SPLICE
0cd0: ce 16 0f  -         dec candidates_length						//dec array length
0cd3: a6 3f     -         ldx TEMPX									//restore x
0cd5: 4c 9d 0c  -         jmp cont									//return to loop
0cd8: ad 16 0f  - FILTER_SIDE_PROXIMIY:lda candidates_length
0cdb: c9 01     -         cmp #1
0cdd: b0 01     -         bcs start										//cont if 1 or more
0cdf: 60        -         rts												//else exit, if no candidates
0ce0: ae 16 0f  - start:  ldx candidates_length							//number of grids yet to check
0ce3: ca        -         dex												//to zero offset
0ce4: 8a        - each:   txa
0ce5: 0a        -         asl												//double, because datasize is 2
0ce6: a8        -         tay												//offset in y (zero based x * datasize)
0ce7: b9 06 0f  -         lda candidates, y
0cea: 8d 00 0f  -         sta grid_pointer
0ced: b9 0e 0f  -         lda candidates_vectors,y
0cf0: 8d 02 0f  -         sta direction_pointer
0cf3: c8        -         iny
0cf4: b9 06 0f  -         lda candidates, y
0cf7: 8d 01 0f  -         sta grid_pointer+1
0cfa: b9 0e 0f  -         lda candidates_vectors,y
0cfd: 8d 03 0f  -         sta direction_pointer+1
0d00: a9 c8     -         lda #<addr
0d02: 85 50     -         sta X
0d04: a9 09     -         lda #>addr
0d06: 85 51     -         sta X+1
0d08: a9 17     -         lda #<addr
0d0a: 85 4e     -         sta X
0d0c: a9 0f     -         lda #>addr
0d0e: 85 4f     -         sta X+1
0d10: a0 08     -         ldy #length											
0d12: 88        -         dey
0d13: b1 50     - copy:   lda (BV7),y
0d15: 91 4e     -         sta (BV9),y
0d17: 88        -         dey
0d18: 10 f9     -         bpl copy
0d1a: a0 01     -         ldy #01											//y?
0d1c: b9 02 0f  -         lda direction_pointer,y
0d1f: d0 01     -         bne ok											//if not zero, than this is right dimension
0d21: 88        -         dey												//not y, but x
0d22: b9 02 0f  - ok:     lda direction_pointer,y							//index of dimension now in y register
0d25: 99 17 0f  -         sta proximity_vectors,y							//set sequence 1,1,0,0 on the right dimension, datasize=2
0d28: c8        -         iny
0d29: c8        -         iny
0d2a: 99 17 0f  -         sta proximity_vectors,y	
0d2d: c8        -         iny
0d2e: c8        -         iny
0d2f: a9 00     -         lda #0
0d31: 99 17 0f  -         sta proximity_vectors,y	
0d34: c8        -         iny
0d35: c8        -         iny
0d36: 99 17 0f  -         sta proximity_vectors,y							//proximity vectors ready
0d39: a0 00     -         ldy #00
0d3b: ad 00 0f  - repeat: lda grid_pointer
0d3e: 18        -         clc
0d3f: 79 17 0f  -         adc proximity_vectors,y
0d42: 8d 04 0f  -         sta test_pointer
0d45: c8        -         iny
0d46: ad 01 0f  -         lda grid_pointer+1
0d49: 18        -         clc
0d4a: 79 17 0f  -         adc proximity_vectors,y
0d4d: 8d 05 0f  -         sta test_pointer+1								//next grid now in test_pointer
0d50: 84 40     -         sty TEMPY										//save y
0d52: ad fc 0e  -         lda X
0d55: 85 fb     -         sta Y
0d57: ad fd 0e  -         lda X + 1
0d5a: 85 fc     -         sta Y + 1
0d5c: a9 00     -         lda #0
0d5e: 85 fe     -         sta ZP4				
0d60: ad 05 0f  -         lda grid+1		
0d63: 85 fd     -         sta ZP3
0d65: a0 03     -         ldy #03
0d67: 06 fd     - mul8:   asl X
0d69: 26 fe     -         rol X+1	
0d6b: 88        -         dey
0d6c: d0 f9     -         bne mul8
0d6e: 18        -         clc
0d6f: a5 fb     -         lda X
0d71: 65 fd     -         adc Y
0d73: 85 fb     -         sta X
0d75: 90 02     -         bcc skip
0d77: e6 fc     -         inc X+1
0d79: 18        - skip:   clc
0d7a: a5 fc     -         lda X+1
0d7c: 65 fe     -         adc Y+1
0d7e: 85 fc     -         sta X+1	
0d80: a0 02     -         ldy #02	
0d82: 06 fd     - mul32:  asl X
0d84: 26 fe     -         rol X+1	
0d86: 88        -         dey
0d87: d0 f9     -         bne mul32
0d89: 18        -         clc
0d8a: a5 fb     -         lda X
0d8c: 65 fd     -         adc Y
0d8e: 85 fb     -         sta X
0d90: 90 02     -         bcc skip
0d92: e6 fc     -         inc X+1
0d94: 18        - skip:   clc
0d95: a5 fc     -         lda X+1
0d97: 65 fe     -         adc Y+1
0d99: 85 fc     -         sta X+1	
0d9b: 18        -         clc
0d9c: a5 fb     -         lda X
0d9e: 6d 04 0f  -         adc y	
0da1: 85 fb     -         sta X
0da3: 90 02     -         bcc out+2
0da5: e6 fc     - out:    inc X+1
0da7: a0 00     -         ldy #0
0da9: b1 fb     -         lda (ZP1),y
0dab: c9 20     -         cmp #DOT										//is dot? (empty)
0dad: f0 0e     -         beq shift										//yes, shift on x
0daf: a4 40     -         ldy TEMPY										//restore y
0db1: c8        -         iny
0db2: c0 08     -         cpy #08
0db4: d0 85     -         bne repeat
0db6: ca        - cont:   dex
0db7: 30 03     -         bmi out										//less than zero, stop
0db9: 4c e4 0c  -         jmp each										//loop back, branch too far
0dbc: 60        - out:    rts
0dbd: 86 3f     - shift:  stx TEMPX									//save x
0dbf: 86 47     -         stx VAR_A									//set index to VAR_A
0dc1: ad 16 0f  -         lda X
0dc4: 85 48     -         sta Y
0dc6: a9 06     -         lda #<addr
0dc8: 85 43     -         sta X
0dca: a9 0f     -         lda #>addr
0dcc: 85 44     -         sta X+1
0dce: a9 02     -         lda #data_size
0dd0: 85 49     -         sta VAR_C
0dd2: 20 c3 08  -         jsr SPLICE
0dd5: ad 16 0f  -         lda X
0dd8: 85 48     -         sta Y
0dda: a9 0e     -         lda #<addr
0ddc: 85 43     -         sta X
0dde: a9 0f     -         lda #>addr
0de0: 85 44     -         sta X+1
0de2: a9 02     -         lda #data_size
0de4: 85 49     -         sta VAR_C
0de6: 20 c3 08  -         jsr SPLICE
0de9: ce 16 0f  -         dec candidates_length						//dec array length
0dec: a6 3f     -         ldx TEMPX									//restore x
0dee: 4c b6 0d  -         jmp cont									//return to loop
0df1: a5 71     - CANDIDATE_FROM_STACK:lda X
0df3: 38        -         sec
0df4: e9 02     -         sbc #C
0df6: 85 71     -         sta X
0df8: b0 02     -         bcs out+2
0dfa: c6 72     - out:    dec X+1
0dfc: a0 00     -         ldy #0									//x
0dfe: b1 71     -         lda (STKPTR1),y
0e00: 99 0e 0f  -         sta candidates_vectors,y
0e03: c8        -         iny										//y
0e04: b1 71     -         lda (STKPTR1),y
0e06: 99 0e 0f  -         sta candidates_vectors,y
0e09: a5 71     -         lda X
0e0b: 38        -         sec
0e0c: e9 02     -         sbc #C
0e0e: 85 71     -         sta X
0e10: b0 02     -         bcs out+2
0e12: c6 72     - out:    dec X+1
0e14: a0 00     -         ldy #0									//x
0e16: b1 71     -         lda (STKPTR1),y
0e18: 99 06 0f  -         sta candidates,y
0e1b: c8        -         iny										//y
0e1c: b1 71     -         lda (STKPTR1),y
0e1e: 99 06 0f  -         sta candidates,y
0e21: a9 01     -         lda #01
0e23: 8d 16 0f  -         sta candidates_length
0e26: 60        - out:    rts
0e27: ae 16 0f  - CHECK_BIAS:ldx candidates_length
0e2a: ca        -         dex
0e2b: 8a        - each:   txa
0e2c: 0a        -         asl 								// length to offset in
0e2d: a8        -         tay									// y
0e2e: b9 0e 0f  -         lda candidates_vectors,y			// x dim
0e31: cd 21 0f  -         cmp bias_direction
0e34: d0 09     -         bne not 							//not same
0e36: c8        -         iny
0e37: b9 0e 0f  -         lda	candidates_vectors,y			// y dim	
0e3a: cd 22 0f  -         cmp bias_direction+1				//the same
0e3d: f0 06     -         beq found
0e3f: ca        - not:    dex
0e40: 10 e9     -         bpl each
0e42: a9 ff     -         lda #-1								//not found: -1
0e44: 60        -         rts
0e45: 8a        - found:  txa									//index in acc
0e46: 60        -         rts
0e47: 20 d0 09  - MAZE:   jsr MAZE_FILL
0e4a: 20 eb 09  - outer,P_LOOP:jsr MAZE_DOT
0e4d: 20 47 0a  -         jsr POINTERS_FROM_START
0e50: 20 7f 0a  -         jsr FILTER_IF_OUT
0e53: 20 e2 0a  -         jsr FILTER_IF_DOT
0e56: 20 04 0c  -         jsr FILTER_IF_CLOSE_PRIMARY
0e59: 20 d8 0c  -         jsr FILTER_SIDE_PROXIMIY
0e5c: ad 16 0f  -         lda candidates_length						//check how many we have
0e5f: c9 00     -         cmp #00										//if zero break;
0e61: f0 6a     -         beq S_LOOP									//goto stack loop
0e63: c9 02     -         cmp #02										//if it is two or more
0e65: b0 05     -         bcs then									//go to else/then
0e67: a9 00     -         lda #0										//otherwise, index->0 in A									
0e69: 4c 93 0e  -         jmp skip_else
0e6c: ad 20 0f  - then:   lda bias_counter
0e6f: c9 00     -         cmp #00
0e71: f0 07     -         beq select_random							//use random, not bias
0e73: 20 27 0e  -         jsr CHECK_BIAS								//index in a, or -1 if not found
0e76: c9 ff     -         cmp #-1
0e78: d0 19     -         bne skip_else								//not -1, select this direction
0e7a: a9 00     - select_random:lda #0										//reset bias counter when selection is random	
0e7c: 8d 20 0f  -         sta bias_counter
0e7f: ad 16 0f  -         lda candidates_length						//random index (, candidates length-1)
0e82: aa        -         tax
0e83: ca        -         dex
0e84: 86 02     -         stx ZP0
0e86: a5 02     -         lda X	
0e88: 85 fd     -         sta ZP3
0e8a: a9 00     -         lda #0
0e8c: 85 fe     -         sta ZP4
0e8e: 20 90 09  -         jsr rnd_X
0e91: a5 14     -         lda WINT
0e93: 85 02     - skip_else:sta ZP0										//store index in ZP0	
0e95: 0a        -         asl 										//datasize=2	
0e96: a8        -         tay											//offset in y
0e97: b9 06 0f  -         lda candidates,y
0e9a: 8d fe 0e  -         sta maze_start
0e9d: b9 0e 0f  -         lda candidates_vectors,y
0ea0: 8d 21 0f  -         sta bias_direction
0ea3: c8        -         iny
0ea4: b9 06 0f  -         lda candidates,y
0ea7: 8d ff 0e  -         sta maze_start+1
0eaa: b9 0e 0f  -         lda candidates_vectors,y
0ead: 8d 22 0f  -         sta bias_direction+1
0eb0: ee 20 0f  -         inc bias_counter
0eb3: ad 20 0f  -         lda bias_counter
0eb6: cd 1f 0f  -         cmp bias
0eb9: d0 05     -         bne out+3
0ebb: a9 00     -         lda #00
0ebd: 8d 20 0f  - out:    sta bias_counter
0ec0: ad 16 0f  -         lda candidates_length
0ec3: c9 02     -         cmp #02										//if there are 2 or more, selected has not been discarded yet
0ec5: 90 03     -         bcc repeat_P								//no, repeat loop
0ec7: 20 93 0b  -         jsr PUSH_REST_ON_STACK													
0eca: 4c 4a 0e  - repeat_P:jmp P_LOOP
0ecd: a5 71     - S_LOOP: lda STKPTR1
0ecf: c9 00     -         cmp #<STACK
0ed1: d0 09     -         bne cont
0ed3: a5 72     -         lda STKPTR2
0ed5: c9 c0     -         cmp #>STACK
0ed7: d0 03     -         bne cont
0ed9: 4c fb 0e  -         jmp quit									//stack pointer == STACK, stack is empty
0edc: 20 f1 0d  - cont:   jsr CANDIDATE_FROM_STACK					//take on grid an its direction from stack
0edf: 20 04 0c  -         jsr FILTER_IF_CLOSE_PRIMARY					//recheck if they are still 'safe'
0ee2: 20 d8 0c  -         jsr FILTER_SIDE_PROXIMIY					//in terms of proximity
0ee5: ad 16 0f  -         lda candidates_length						//check if it is still ok
0ee8: c9 00     -         cmp #00										//if zero break; 
0eea: f0 e1     -         beq S_LOOP									//no, find another
0eec: ad 06 0f  -         lda candidates								//set it to maze_start
0eef: 8d fe 0e  -         sta maze_start
0ef2: ad 07 0f  -         lda candidates+1
0ef5: 8d ff 0e  -         sta maze_start+1
0ef8: 4c 4a 0e  -         jmp P_LOOP									//make next branch
0efb: 60        - quit:   rts

[MAZE Memory]
0efc: 04 00     - MAZE_memory,maze_memory_alloc:.word $0004 					//screen by default
0efe: 00 00     - maze_start:.word 0
0f00: 00 00     - grid_pointer:.word 0
0f02: 00 00     - direction_pointer:.word 0
0f04: 00 00     - test_pointer:.word 0
0f06: 00 00     - candidates:.fill 2,0
0f08: 00 00     -         .fill 2,0
0f0a: 00 00     -         .fill 2,0
0f0c: 00 00     -         .fill 2,0
0f0e: 00 00     - candidates_vectors:.fill 2,0
0f10: 00 00     -         .fill 2,0
0f12: 00 00     -         .fill 2,0
0f14: 00 00     -         .fill 2,0
0f16: 00        - candidates_length:.byte 0
0f17: 00 00     - proximity_vectors:.fill 2,0
0f19: 00 00     -         .fill 2,0
0f1b: 00 00     -         .fill 2,0
0f1d: 00 00     -         .fill 2,0
0f1f: 02        - bias:   .byte 2
0f20: 00        - bias_counter:.byte 0
0f21: 00 00     - bias_direction:.word 0

[Subroutines]
0f23: ad 66 0f  - subs,irqcode:lda modeflag
0f26: f0 03     -         beq mode1
0f28: 4c 40 0f  -         jmp mode2
0f2b: a9 01     - mode1:  lda #$01
0f2d: 8d 66 0f  -         sta modeflag
0f30: a9 00     -         lda #BLACK
0f32: 8d 20 d0  -         sta BORDER
0f35: a9 32     -         lda #startRaster
0f37: 8d 12 d0  -         sta RASTER_COUNTER
0f3a: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
0f3d: 4c 31 ea  -         jmp IRQOUT
0f40: a9 00     - mode2:  lda #$00
0f42: 8d 66 0f  -         sta modeflag
0f45: a9 0f     -         lda #LIGHTGREY
0f47: 8d 20 d0  -         sta BORDER
0f4a: a9 fa     -         lda #endRaster
0f4c: 8d 12 d0  -         sta RASTER_COUNTER
0f4f: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
0f52: 68        -         pla
0f53: a8        -         tay
0f54: 68        -         pla
0f55: aa        -         tax
0f56: 68        -         pla
0f57: 40        -         rti
0f58: a2 00     - set_bricks:ldx #00
0f5a: bd 69 0f  - copy:   lda brick_data,x
0f5d: 9d 00 30  -         sta char_offset,x
0f60: e8        -         inx
0f61: e0 08     -         cpx #08
0f63: d0 f5     -         bne copy
0f65: 60        -         rts

[Data]
0f66: 00        - text,data,modeflag:.byte 0
0f67: 00        - startX: .byte 0
0f68: 00        - startY: .byte 0
0f69: dd c1 38 bb bb 83 1c dd                          - brick_data:.byte $dd,$c1,$38,$bb,$bb,$83,$1c,$dd
