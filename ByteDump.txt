******************************* Segment: Default *******************************
[Header]
0801: 0c 08     -         .word bend
0803: 0d 00     -         .byte $0d, $00				//;line number
0805: 9e        -         .byte $9E					//;SYS
0806: 20        -         .byte $20					//;space
0807: 32 30 36 34                                      -         .byte $32,$30,$36,$34		//;start 2064
080b: 00        -         .byte $00					//;end of line
080c: 00 00     - bend:   .byte $00, $00				//;end of basic program

[Main]
0810: 78        -         sei							//set interrupt
0811: a9 7f     -         lda #$7f
0813: 8d 0d dc  -         sta CIA_ICR
0816: 8d 0d dd  -         sta CIA2_ICR
0819: ad 0d dc  -         lda CIA_ICR
081c: ad 0d dd  -         lda CIA2_ICR
081f: ad 1a d0  -         lda INTERRUPT_MASK_REGISTER	
0822: 09 01     -         ora #$01
0824: 8d 1a d0  -         sta INTERRUPT_MASK_REGISTER
0827: ad 11 d0  -         lda CONTROL_REGISTER1
082a: 29 7f     -         and #$7f
082c: 8d 11 d0  -         sta CONTROL_REGISTER1
082f: a9 32     -         lda #startRaster
0831: 8d 12 d0  -         sta RASTER_COUNTER
0834: a9 b5     -         lda #<address
0836: 8d 14 03  -         sta IRQVEC
0839: a9 0e     -         lda #>address
083b: 8d 15 03  -         sta	IRQVEC+1
083e: 58        -         cli
083f: d8        - begin:  cld
0840: a9 26     - init:   lda #<end	
0842: 85 fd     -         sta ZP3
0844: a9 00     -         lda #>end
0846: 85 fe     -         sta ZP4
0848: a9 01     -         lda #<start
084a: 85 fb     -         sta ZP1
084c: a9 00     -         lda #>start
084e: 85 fc     -         sta ZP2
0850: 20 f7 08  -         jsr rnd_XY
0853: a5 14     -         lda X
0855: 8d eb 0e  -         sta Y
0858: a9 17     -         lda #<end	
085a: 85 fd     -         sta ZP3
085c: a9 00     -         lda #>end
085e: 85 fe     -         sta ZP4
0860: a9 01     -         lda #<start
0862: 85 fb     -         sta ZP1
0864: a9 00     -         lda #>start
0866: 85 fc     -         sta ZP2
0868: 20 f7 08  -         jsr rnd_XY
086b: a5 14     -         lda X
086d: 8d ec 0e  -         sta Y
0870: a9 00     -         lda #<addr
0872: 8d 8f 0e  -         sta X
0875: a9 04     -         lda #>addr
0877: 8d 90 0e  -         sta X+1
087a: ad eb 0e  -         lda X
087d: 8d 91 0e  -         sta Y
0880: ad ec 0e  -         lda X + 1
0883: 8d 92 0e  -         sta Y + 1
0886: a9 00     -         lda #<addr
0888: 85 71     -         sta X
088a: a9 c0     -         lda #>addr
088c: 85 72     -         sta X+1
088e: 20 03 0e  -         jsr MAZE
0891: a5 c5     - end,key:lda LSTX		//get character in A
0893: c9 40     -         cmp #64			//no key
0895: f0 fa     -         beq key
0897: 4c 40 08  -         jmp init
089a: 60        -         rts

[Imports]
089b: c6 48     - imports,SPLICE:dec VAR_B								//array length - 1, last index
089d: a4 47     -         ldy VAR_A								//index
089f: c4 48     - loop:   cpy VAR_B								//stop if index
08a1: 10 35     -         bpl out 								//equal or greater than last index
08a3: a2 00     -         ldx #0									//number of properties (data_size), start from 0
08a5: c8        - each:   iny		
08a6: 84 40     -         sty TEMPY
08a8: a5 49     -         lda	VAR_C 								//data size
08aa: 20 d9 08  -         jsr MUL_Y_A
08ad: 84 02     -         sty ZP0
08af: 8a        -         txa
08b0: 18        -         clc
08b1: 65 02     -         adc ZP0
08b3: a8        -         tay
08b4: b1 43     -         lda (BV1),y
08b6: 85 41     -         sta TEMPA1
08b8: a4 40     -         ldy TEMPY
08ba: 88        -         dey
08bb: 84 40     -         sty TEMPY
08bd: a5 49     -         lda	VAR_C 								//data size
08bf: 20 d9 08  -         jsr MUL_Y_A
08c2: 84 02     -         sty ZP0
08c4: 8a        -         txa
08c5: 18        -         clc
08c6: 65 02     -         adc ZP0
08c8: a8        -         tay
08c9: a5 41     -         lda TEMPA1
08cb: 91 43     -         sta (BV1),y
08cd: a4 40     -         ldy TEMPY
08cf: e8        -         inx
08d0: e4 49     -         cpx VAR_C								//all props? less than VAR_C ?
08d2: 90 d1     -         bcc each
08d4: c8        -         iny
08d5: 4c 9f 08  -         jmp loop
08d8: 60        - out:    rts
08d9: c0 00     - MUL_Y_A,multiply:cpy #00
08db: f0 18     -         beq end
08dd: 88        -         dey
08de: 8c eb 08  -         sty mod+1
08e1: 4a        -         lsr
08e2: 85 02     -         sta ZP0
08e4: a9 00     -         lda #00
08e6: a0 08     -         ldy #$08
08e8: 90 02     - loop:   bcc skip
08ea: 69 00     - mod:    adc #0
08ec: 6a        - skip:   ror
08ed: 66 02     -         ror ZP0
08ef: 88        -         dey
08f0: d0 f6     -         bne loop
08f2: a4 02     -         ldy ZP0
08f4: 60        -         rts
08f5: 98        - end:    tya
08f6: 60        -         rts

[SYSTEM_data]
08f7: e6 fd     - SYS_data,rnd_XY:inc ZP3
08f9: d0 02     -         bne skip1
08fb: e6 fe     -         inc ZP4
08fd: a5 fd     - skip1:  lda ZP3
08ff: 38        -         sec
0900: e5 fb     -         sbc ZP1
0902: 85 fd     -         sta ZP3
0904: a5 fe     -         lda ZP4
0906: e5 fc     -         sbc ZP2
0908: 85 fe     -         sta ZP4			
090a: a4 fd     - toFloat:ldy ZP3
090c: a5 fe     -         lda ZP4
090e: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
0911: a2 63     -         ldx #<flt
0913: a0 09     -         ldy #>flt
0915: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
0918: a9 00     -         lda #$00					//RND(0)
091a: 20 9a e0  -         jsr RND						//$E09A
091d: a9 63     -         lda #<flt
091f: a0 09     -         ldy #>flt
0921: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
0924: 20 cc bc  -         jsr FAINT					//to integer
0927: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
092a: a5 65     -         lda $65						//FAC mantissa lo
092c: 18        -         clc
092d: 65 fb     -         adc ZP1						//add number to start	
092f: 85 14     -         sta WINT
0931: a5 64     -         lda $64						//FAC mantissa hi
0933: 65 fc     -         adc ZP2
0935: 85 15     -         sta WINT+1
0937: 60        - over:   rts			
0938: e6 fd     - rnd_X:  inc ZP3
093a: d0 02     -         bne toFloat
093c: e6 fe     -         inc ZP4	
093e: a4 fd     - toFloat:ldy ZP3
0940: a5 fe     -         lda ZP4
0942: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
0945: a2 63     -         ldx #<flt
0947: a0 09     -         ldy #>flt
0949: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
094c: a9 00     -         lda #$00					//get actual RND(0)
094e: 20 9a e0  -         jsr RND						//$E09A
0951: a9 63     -         lda #<flt
0953: a0 09     -         ldy #>flt
0955: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
0958: 20 cc bc  -         jsr FAINT					//to integer
095b: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
095e: a5 65     -         lda $65						//FAC mantissa lo
0960: 85 14     -         sta WINT					
0962: 60        -         rts			

[Data RND]
0963: 00 00 00 00 00                                   - dataRND,flt:.byte 0,0,0,0,0

[Grid_Constants]
0968: 00 ff     - Grid_Constants,BASIC_DIRS,UP:.byte 	0, -1
096a: 00 01     - DOWN:   .byte 	0, 1
096c: ff 00     - LEFT:   .byte	-1, 0
096e: 01 00     - RIGHT:  .byte 	1,0
0970: ff ff     - PROX_TEMPLATE:.byte 	-1, -1
0972: 01 01     -         .byte 	1, 1
0974: ff ff     -         .byte 	-1, -1
0976: 01 01     -         .byte 	1, 1
0978: ad 8f 0e  - MAZE_FILL:lda X
097b: 85 fb     -         sta Y
097d: ad 90 0e  -         lda X + 1
0980: 85 fc     -         sta Y + 1
0982: a9 e0     -         lda	#WALL
0984: a2 04     -         ldx #4
0986: a0 00     - block:  ldy #0
0988: 91 fb     - fill:   sta (ZP1),y
098a: c8        -         iny
098b: d0 fb     -         bne fill
098d: e6 fc     -         inc ZP2
098f: ca        -         dex
0990: d0 f4     -         bne block
0992: 60        -         rts
0993: ad 8f 0e  - MAZE_DOT:lda X
0996: 85 fb     -         sta Y
0998: ad 90 0e  -         lda X + 1
099b: 85 fc     -         sta Y + 1
099d: a9 00     -         lda #0
099f: 85 fe     -         sta ZP4				
09a1: ad 92 0e  -         lda grid+1		
09a4: 85 fd     -         sta ZP3
09a6: a0 03     -         ldy #03
09a8: 06 fd     - mul8:   asl X
09aa: 26 fe     -         rol X+1	
09ac: 88        -         dey
09ad: d0 f9     -         bne mul8
09af: 18        -         clc
09b0: a5 fb     -         lda X
09b2: 65 fd     -         adc Y
09b4: 85 fb     -         sta X
09b6: 90 02     -         bcc skip
09b8: e6 fc     -         inc X+1
09ba: 18        - skip:   clc
09bb: a5 fc     -         lda X+1
09bd: 65 fe     -         adc Y+1
09bf: 85 fc     -         sta X+1	
09c1: a0 02     -         ldy #02	
09c3: 06 fd     - mul32:  asl X
09c5: 26 fe     -         rol X+1	
09c7: 88        -         dey
09c8: d0 f9     -         bne mul32
09ca: 18        -         clc
09cb: a5 fb     -         lda X
09cd: 65 fd     -         adc Y
09cf: 85 fb     -         sta X
09d1: 90 02     -         bcc skip
09d3: e6 fc     -         inc X+1
09d5: 18        - skip:   clc
09d6: a5 fc     -         lda X+1
09d8: 65 fe     -         adc Y+1
09da: 85 fc     -         sta X+1	
09dc: 18        -         clc
09dd: a5 fb     -         lda X
09df: 6d 91 0e  -         adc y	
09e2: 85 fb     -         sta X
09e4: 90 02     -         bcc out+2
09e6: e6 fc     - out:    inc X+1
09e8: a9 20     -         lda #DOT
09ea: a0 00     -         ldy #0
09ec: 91 fb     -         sta (ZP1),y
09ee: 60        -         rts
09ef: a9 99     - POINTERS_FROM_START:lda #<addr
09f1: 85 45     -         sta X
09f3: a9 0e     -         lda #>addr
09f5: 85 46     -         sta X+1
09f7: a9 68     -         lda #<addr
09f9: 85 fd     -         sta X
09fb: a9 09     -         lda #>addr
09fd: 85 fe     -         sta X+1
09ff: a2 03     -         ldx #03
0a01: 8a        - add:    txa
0a02: 0a        -         asl
0a03: a8        -         tay		
0a04: 18        -         clc
0a05: ad 91 0e  -         lda maze_start
0a08: 71 fd     -         adc (ZP3),y
0a0a: 91 45     -         sta (BV3),y
0a0c: c8        -         iny
0a0d: 18        -         clc
0a0e: ad 92 0e  -         lda maze_start+1
0a11: 71 fd     -         adc (ZP3),y
0a13: 91 45     -         sta (BV3),y
0a15: ca        -         dex
0a16: 10 e9     -         bpl add
0a18: a9 a1     -         lda #<addr
0a1a: 85 4b     -         sta X
0a1c: a9 0e     -         lda #>addr
0a1e: 85 4c     -         sta X+1
0a20: a2 03     -         ldx #03
0a22: 8a        - copy:   txa
0a23: 0a        -         asl
0a24: a8        -         tay	
0a25: b1 fd     -         lda (ZP3),y
0a27: 91 4b     -         sta (BV5),y
0a29: c8        -         iny
0a2a: b1 fd     -         lda (ZP3),y
0a2c: 91 4b     -         sta (BV5),y
0a2e: ca        -         dex
0a2f: 10 f1     -         bpl copy
0a31: a9 04     -         lda #04
0a33: 8d a9 0e  -         sta candidates_length
0a36: 60        -         rts
0a37: ad a9 0e  - FILTER_IF_OUT:lda candidates_length
0a3a: c9 01     -         cmp #1
0a3c: b0 01     -         bcs start
0a3e: 60        -         rts
0a3f: a9 99     - start:  lda #<addr
0a41: 85 45     -         sta X
0a43: a9 0e     -         lda #>addr
0a45: 85 46     -         sta X+1
0a47: ae a9 0e  -         ldx candidates_length				//number of grids yet to check
0a4a: ca        -         dex
0a4b: 8a        - each:   txa
0a4c: 0a        -         asl
0a4d: a8        -         tay
0a4e: 18        -         clc
0a4f: b1 45     -         lda (BV3),y	
0a51: c9 27     -         cmp #MAX_X+1
0a53: b0 17     -         bcs shift
0a55: c9 01     -         cmp #MIN_X
0a57: 90 13     -         bcc shift
0a59: c8        -         iny
0a5a: 18        -         clc
0a5b: b1 45     -         lda (BV3),y
0a5d: c9 18     -         cmp #MAX_Y+1
0a5f: b0 0b     -         bcs shift
0a61: c9 01     -         cmp #MIN_Y
0a63: 90 07     -         bcc shift
0a65: ca        - cont:   dex
0a66: 30 03     -         bmi out
0a68: 4c 4b 0a  -         jmp each
0a6b: 60        - out:    rts
0a6c: 86 3f     - shift:  stx TEMPX									//save x							
0a6e: 86 47     -         stx VAR_A									//set index to VAR_A
0a70: ad a9 0e  -         lda X
0a73: 85 48     -         sta Y
0a75: a9 99     -         lda #<addr
0a77: 85 43     -         sta X
0a79: a9 0e     -         lda #>addr
0a7b: 85 44     -         sta X+1
0a7d: a9 02     -         lda #data_size
0a7f: 85 49     -         sta VAR_C
0a81: 20 9b 08  -         jsr SPLICE
0a84: ad a9 0e  -         lda X
0a87: 85 48     -         sta Y
0a89: a9 a1     -         lda #<addr
0a8b: 85 43     -         sta X
0a8d: a9 0e     -         lda #>addr
0a8f: 85 44     -         sta X+1
0a91: a9 02     -         lda #data_size
0a93: 85 49     -         sta VAR_C
0a95: 20 9b 08  -         jsr SPLICE
0a98: ce a9 0e  -         dec candidates_length						//dec array length
0a9b: a6 3f     -         ldx TEMPX									//restore x
0a9d: 4c 65 0a  -         jmp cont									//return to loop
0aa0: ad a9 0e  - FILTER_IF_DOT:lda candidates_length
0aa3: c9 01     -         cmp #1
0aa5: b0 01     -         bcs start
0aa7: 60        -         rts
0aa8: a9 99     - start:  lda #<addr
0aaa: 85 45     -         sta X
0aac: a9 0e     -         lda #>addr
0aae: 85 46     -         sta X+1
0ab0: ae a9 0e  -         ldx candidates_length						//number of grids yet to check
0ab3: ca        -         dex
0ab4: 8a        - each:   txa
0ab5: 0a        -         asl
0ab6: a8        -         tay
0ab7: b1 45     -         lda (BV3),y
0ab9: 8d 93 0e  -         sta grid_pointer
0abc: c8        -         iny
0abd: b1 45     -         lda (BV3),y
0abf: 8d 94 0e  -         sta grid_pointer+1
0ac2: ad 8f 0e  -         lda X
0ac5: 85 fb     -         sta Y
0ac7: ad 90 0e  -         lda X + 1
0aca: 85 fc     -         sta Y + 1
0acc: a9 00     -         lda #0
0ace: 85 fe     -         sta ZP4				
0ad0: ad 94 0e  -         lda grid+1		
0ad3: 85 fd     -         sta ZP3
0ad5: a0 03     -         ldy #03
0ad7: 06 fd     - mul8:   asl X
0ad9: 26 fe     -         rol X+1	
0adb: 88        -         dey
0adc: d0 f9     -         bne mul8
0ade: 18        -         clc
0adf: a5 fb     -         lda X
0ae1: 65 fd     -         adc Y
0ae3: 85 fb     -         sta X
0ae5: 90 02     -         bcc skip
0ae7: e6 fc     -         inc X+1
0ae9: 18        - skip:   clc
0aea: a5 fc     -         lda X+1
0aec: 65 fe     -         adc Y+1
0aee: 85 fc     -         sta X+1	
0af0: a0 02     -         ldy #02	
0af2: 06 fd     - mul32:  asl X
0af4: 26 fe     -         rol X+1	
0af6: 88        -         dey
0af7: d0 f9     -         bne mul32
0af9: 18        -         clc
0afa: a5 fb     -         lda X
0afc: 65 fd     -         adc Y
0afe: 85 fb     -         sta X
0b00: 90 02     -         bcc skip
0b02: e6 fc     -         inc X+1
0b04: 18        - skip:   clc
0b05: a5 fc     -         lda X+1
0b07: 65 fe     -         adc Y+1
0b09: 85 fc     -         sta X+1	
0b0b: 18        -         clc
0b0c: a5 fb     -         lda X
0b0e: 6d 93 0e  -         adc y	
0b11: 85 fb     -         sta X
0b13: 90 02     -         bcc out+2
0b15: e6 fc     - out:    inc X+1
0b17: a0 00     -         ldy #0
0b19: b1 fb     -         lda (ZP1),y
0b1b: c9 20     -         cmp #DOT
0b1d: f0 04     -         beq shift
0b1f: ca        - cont:   dex
0b20: 10 92     -         bpl each
0b22: 60        - out:    rts
0b23: 86 3f     - shift:  stx TEMPX									//save x
0b25: 86 47     -         stx VAR_A									//set index to VAR_A
0b27: ad a9 0e  -         lda X
0b2a: 85 48     -         sta Y
0b2c: a9 99     -         lda #<addr
0b2e: 85 43     -         sta X
0b30: a9 0e     -         lda #>addr
0b32: 85 44     -         sta X+1
0b34: a9 02     -         lda #data_size
0b36: 85 49     -         sta VAR_C
0b38: 20 9b 08  -         jsr SPLICE
0b3b: ad a9 0e  -         lda X
0b3e: 85 48     -         sta Y
0b40: a9 a1     -         lda #<addr
0b42: 85 43     -         sta X
0b44: a9 0e     -         lda #>addr
0b46: 85 44     -         sta X+1
0b48: a9 02     -         lda #data_size
0b4a: 85 49     -         sta VAR_C
0b4c: 20 9b 08  -         jsr SPLICE
0b4f: ce a9 0e  -         dec candidates_length						//dec array length
0b52: a6 3f     -         ldx TEMPX									//restore x
0b54: 4c 1f 0b  -         jmp cont									//return to loop
0b57: a5 02     - PUSH_REST_ON_STACK:lda ZP0										//index was stored in ZP0
0b59: 85 47     -         sta VAR_A									//set index to VAR_A
0b5b: ad a9 0e  -         lda X
0b5e: 85 48     -         sta Y
0b60: a9 99     -         lda #<addr
0b62: 85 43     -         sta X
0b64: a9 0e     -         lda #>addr
0b66: 85 44     -         sta X+1
0b68: a9 02     -         lda #data_size
0b6a: 85 49     -         sta VAR_C
0b6c: 20 9b 08  -         jsr SPLICE
0b6f: ad a9 0e  -         lda X
0b72: 85 48     -         sta Y
0b74: a9 a1     -         lda #<addr
0b76: 85 43     -         sta X
0b78: a9 0e     -         lda #>addr
0b7a: 85 44     -         sta X+1
0b7c: a9 02     -         lda #data_size
0b7e: 85 49     -         sta VAR_C
0b80: 20 9b 08  -         jsr SPLICE
0b83: ce a9 0e  -         dec candidates_length						//dec array length
0b86: a2 00     -         ldx #0
0b88: a0 00     - each:   ldy #0
0b8a: 86 3f     -         stx TEMPX									//save x
0b8c: 8a        -         txa											//x = x *2	
0b8d: 0a        -         asl 
0b8e: aa        -         tax									
0b8f: bd 99 0e  -         lda candidates,x							//x
0b92: 91 71     -         sta (STKPTR1),y
0b94: c8        -         iny
0b95: e8        -         inx
0b96: bd 99 0e  -         lda candidates,x							//y
0b99: 91 71     -         sta (STKPTR1),y
0b9b: 18        -         clc
0b9c: a5 71     -         lda X
0b9e: 69 02     -         adc #C
0ba0: 85 71     -         sta X
0ba2: 90 02     -         bcc out+2
0ba4: e6 72     - out:    inc X+1
0ba6: 88        -         dey
0ba7: ca        -         dex
0ba8: bd a1 0e  -         lda candidates_vectors,x					//x
0bab: 91 71     -         sta (STKPTR1),y
0bad: c8        -         iny
0bae: e8        -         inx
0baf: bd a1 0e  -         lda candidates_vectors,x					//y
0bb2: 91 71     -         sta (STKPTR1),y
0bb4: 18        -         clc
0bb5: a5 71     -         lda X
0bb7: 69 02     -         adc #C
0bb9: 85 71     -         sta X
0bbb: 90 02     -         bcc out+2
0bbd: e6 72     - out:    inc X+1
0bbf: a6 3f     -         ldx TEMPX									//restore x
0bc1: e8        -         inx
0bc2: ec a9 0e  -         cpx candidates_length
0bc5: d0 c1     -         bne each
0bc7: 60        - out:    rts		
0bc8: ad a9 0e  - FILTER_IF_CLOSE_PRIMARY:lda candidates_length
0bcb: c9 01     -         cmp #1
0bcd: b0 01     -         bcs start										//cont if 1 or more
0bcf: 60        -         rts												//else exit, if no candidates
0bd0: a9 99     - start:  lda #<addr
0bd2: 85 45     -         sta X
0bd4: a9 0e     -         lda #>addr
0bd6: 85 46     -         sta X+1
0bd8: a9 a1     -         lda #<addr
0bda: 85 4b     -         sta X
0bdc: a9 0e     -         lda #>addr
0bde: 85 4c     -         sta X+1
0be0: ae a9 0e  -         ldx candidates_length							//number of grids yet to check
0be3: ca        -         dex												//to zero offset
0be4: 8a        - each:   txa
0be5: 0a        -         asl												//double, because datasize is 2
0be6: a8        -         tay												//offset in y (zero based x * datasize)
0be7: b1 45     -         lda (BV3),y
0be9: 8d 93 0e  -         sta grid_pointer
0bec: b1 4b     -         lda (BV5),y
0bee: 8d 95 0e  -         sta direction_pointer
0bf1: c8        -         iny
0bf2: b1 45     -         lda (BV3),y
0bf4: 8d 94 0e  -         sta grid_pointer+1
0bf7: b1 4b     -         lda (BV5),y
0bf9: 8d 96 0e  -         sta direction_pointer+1
0bfc: 18        -         clc
0bfd: ad 93 0e  -         lda grid_pointer
0c00: 6d 95 0e  -         adc direction_pointer
0c03: 8d 97 0e  -         sta test_pointer
0c06: 18        -         clc
0c07: ad 94 0e  -         lda grid_pointer+1
0c0a: 6d 96 0e  -         adc direction_pointer+1
0c0d: 8d 98 0e  -         sta test_pointer+1
0c10: ad 8f 0e  -         lda X
0c13: 85 fb     -         sta Y
0c15: ad 90 0e  -         lda X + 1
0c18: 85 fc     -         sta Y + 1
0c1a: a9 00     -         lda #0
0c1c: 85 fe     -         sta ZP4				
0c1e: ad 98 0e  -         lda grid+1		
0c21: 85 fd     -         sta ZP3
0c23: a0 03     -         ldy #03
0c25: 06 fd     - mul8:   asl X
0c27: 26 fe     -         rol X+1	
0c29: 88        -         dey
0c2a: d0 f9     -         bne mul8
0c2c: 18        -         clc
0c2d: a5 fb     -         lda X
0c2f: 65 fd     -         adc Y
0c31: 85 fb     -         sta X
0c33: 90 02     -         bcc skip
0c35: e6 fc     -         inc X+1
0c37: 18        - skip:   clc
0c38: a5 fc     -         lda X+1
0c3a: 65 fe     -         adc Y+1
0c3c: 85 fc     -         sta X+1	
0c3e: a0 02     -         ldy #02	
0c40: 06 fd     - mul32:  asl X
0c42: 26 fe     -         rol X+1	
0c44: 88        -         dey
0c45: d0 f9     -         bne mul32
0c47: 18        -         clc
0c48: a5 fb     -         lda X
0c4a: 65 fd     -         adc Y
0c4c: 85 fb     -         sta X
0c4e: 90 02     -         bcc skip
0c50: e6 fc     -         inc X+1
0c52: 18        - skip:   clc
0c53: a5 fc     -         lda X+1
0c55: 65 fe     -         adc Y+1
0c57: 85 fc     -         sta X+1	
0c59: 18        -         clc
0c5a: a5 fb     -         lda X
0c5c: 6d 97 0e  -         adc y	
0c5f: 85 fb     -         sta X
0c61: 90 02     -         bcc out+2
0c63: e6 fc     - out:    inc X+1
0c65: a0 00     -         ldy #0
0c67: b1 fb     -         lda (ZP1),y
0c69: c9 20     -         cmp #DOT									//is dot? (empty)
0c6b: f0 07     -         beq shift									//yes
0c6d: ca        - cont:   dex
0c6e: 30 03     -         bmi out										//less than zero, stop
0c70: 4c e4 0b  -         jmp each									//loop back, branch too far
0c73: 60        - out:    rts
0c74: 86 3f     - shift:  stx TEMPX									//save x
0c76: 86 47     -         stx VAR_A									//set index to VAR_A
0c78: ad a9 0e  -         lda X
0c7b: 85 48     -         sta Y
0c7d: a9 99     -         lda #<addr
0c7f: 85 43     -         sta X
0c81: a9 0e     -         lda #>addr
0c83: 85 44     -         sta X+1
0c85: a9 02     -         lda #data_size
0c87: 85 49     -         sta VAR_C
0c89: 20 9b 08  -         jsr SPLICE
0c8c: ad a9 0e  -         lda X
0c8f: 85 48     -         sta Y
0c91: a9 a1     -         lda #<addr
0c93: 85 43     -         sta X
0c95: a9 0e     -         lda #>addr
0c97: 85 44     -         sta X+1
0c99: a9 02     -         lda #data_size
0c9b: 85 49     -         sta VAR_C
0c9d: 20 9b 08  -         jsr SPLICE
0ca0: ce a9 0e  -         dec candidates_length						//dec array length
0ca3: a6 3f     -         ldx TEMPX									//restore x
0ca5: 4c 6d 0c  -         jmp cont									//return to loop
0ca8: ad a9 0e  - FILTER_SIDE_PROXIMIY:lda candidates_length
0cab: c9 01     -         cmp #1
0cad: b0 01     -         bcs start										//cont if 1 or more
0caf: 60        -         rts												//else exit, if no candidates
0cb0: a9 99     - start:  lda #<addr
0cb2: 85 45     -         sta X
0cb4: a9 0e     -         lda #>addr
0cb6: 85 46     -         sta X+1
0cb8: a9 a1     -         lda #<addr
0cba: 85 4b     -         sta X
0cbc: a9 0e     -         lda #>addr
0cbe: 85 4c     -         sta X+1
0cc0: ae a9 0e  -         ldx candidates_length							//number of grids yet to check
0cc3: ca        -         dex												//to zero offset
0cc4: 8a        - each:   txa
0cc5: 0a        -         asl												//double, because datasize is 2
0cc6: a8        -         tay												//offset in y (zero based x * datasize)
0cc7: b1 45     -         lda (BV3),y
0cc9: 8d 93 0e  -         sta grid_pointer
0ccc: b1 4b     -         lda (BV5),y
0cce: 8d 95 0e  -         sta direction_pointer
0cd1: c8        -         iny
0cd2: b1 45     -         lda (BV3),y
0cd4: 8d 94 0e  -         sta grid_pointer+1
0cd7: b1 4b     -         lda (BV5),y
0cd9: 8d 96 0e  -         sta direction_pointer+1
0cdc: a9 70     -         lda #<addr
0cde: 85 50     -         sta X
0ce0: a9 09     -         lda #>addr
0ce2: 85 51     -         sta X+1
0ce4: a9 aa     -         lda #<addr
0ce6: 85 4e     -         sta X
0ce8: a9 0e     -         lda #>addr
0cea: 85 4f     -         sta X+1
0cec: a0 08     -         ldy #length											
0cee: 88        -         dey
0cef: b1 50     - copy:   lda (BV7),y
0cf1: 91 4e     -         sta (BV9),y
0cf3: 88        -         dey
0cf4: 10 f9     -         bpl copy
0cf6: a0 01     -         ldy #01											//y?
0cf8: b9 95 0e  -         lda direction_pointer,y
0cfb: d0 01     -         bne ok											//if not zero, than this is right dimension
0cfd: 88        -         dey												//not y, but x
0cfe: b9 95 0e  - ok:     lda direction_pointer,y							//index of dimension now in y register
0d01: 99 aa 0e  -         sta proximity_vectors,y							//set sequence 1,1,0,0 on the right dimension, datasize=2
0d04: c8        -         iny
0d05: c8        -         iny
0d06: 99 aa 0e  -         sta proximity_vectors,y	
0d09: c8        -         iny
0d0a: c8        -         iny
0d0b: a9 00     -         lda #0
0d0d: 99 aa 0e  -         sta proximity_vectors,y	
0d10: c8        -         iny
0d11: c8        -         iny
0d12: 99 aa 0e  -         sta proximity_vectors,y							//proximity vectors ready
0d15: a0 00     -         ldy #00
0d17: ad 93 0e  - repeat: lda grid_pointer
0d1a: 18        -         clc
0d1b: 79 aa 0e  -         adc proximity_vectors,y
0d1e: 8d 97 0e  -         sta test_pointer
0d21: c8        -         iny
0d22: ad 94 0e  -         lda grid_pointer+1
0d25: 18        -         clc
0d26: 79 aa 0e  -         adc proximity_vectors,y
0d29: 8d 98 0e  -         sta test_pointer+1								//next grid now in test_pointer
0d2c: 84 40     -         sty TEMPY										//save y
0d2e: ad 8f 0e  -         lda X
0d31: 85 fb     -         sta Y
0d33: ad 90 0e  -         lda X + 1
0d36: 85 fc     -         sta Y + 1
0d38: a9 00     -         lda #0
0d3a: 85 fe     -         sta ZP4				
0d3c: ad 98 0e  -         lda grid+1		
0d3f: 85 fd     -         sta ZP3
0d41: a0 03     -         ldy #03
0d43: 06 fd     - mul8:   asl X
0d45: 26 fe     -         rol X+1	
0d47: 88        -         dey
0d48: d0 f9     -         bne mul8
0d4a: 18        -         clc
0d4b: a5 fb     -         lda X
0d4d: 65 fd     -         adc Y
0d4f: 85 fb     -         sta X
0d51: 90 02     -         bcc skip
0d53: e6 fc     -         inc X+1
0d55: 18        - skip:   clc
0d56: a5 fc     -         lda X+1
0d58: 65 fe     -         adc Y+1
0d5a: 85 fc     -         sta X+1	
0d5c: a0 02     -         ldy #02	
0d5e: 06 fd     - mul32:  asl X
0d60: 26 fe     -         rol X+1	
0d62: 88        -         dey
0d63: d0 f9     -         bne mul32
0d65: 18        -         clc
0d66: a5 fb     -         lda X
0d68: 65 fd     -         adc Y
0d6a: 85 fb     -         sta X
0d6c: 90 02     -         bcc skip
0d6e: e6 fc     -         inc X+1
0d70: 18        - skip:   clc
0d71: a5 fc     -         lda X+1
0d73: 65 fe     -         adc Y+1
0d75: 85 fc     -         sta X+1	
0d77: 18        -         clc
0d78: a5 fb     -         lda X
0d7a: 6d 97 0e  -         adc y	
0d7d: 85 fb     -         sta X
0d7f: 90 02     -         bcc out+2
0d81: e6 fc     - out:    inc X+1
0d83: a0 00     -         ldy #0
0d85: b1 fb     -         lda (ZP1),y
0d87: c9 20     -         cmp #DOT										//is dot? (empty)
0d89: f0 0e     -         beq shift										//yes, shift on x
0d8b: a4 40     -         ldy TEMPY										//restore y
0d8d: c8        -         iny
0d8e: c0 08     -         cpy #08
0d90: d0 85     -         bne repeat
0d92: ca        - cont:   dex
0d93: 30 03     -         bmi out										//less than zero, stop
0d95: 4c c4 0c  -         jmp each										//loop back, branch too far
0d98: 60        - out:    rts
0d99: 86 3f     - shift:  stx TEMPX									//save x
0d9b: 86 47     -         stx VAR_A									//set index to VAR_A
0d9d: ad a9 0e  -         lda X
0da0: 85 48     -         sta Y
0da2: a9 99     -         lda #<addr
0da4: 85 43     -         sta X
0da6: a9 0e     -         lda #>addr
0da8: 85 44     -         sta X+1
0daa: a9 02     -         lda #data_size
0dac: 85 49     -         sta VAR_C
0dae: 20 9b 08  -         jsr SPLICE
0db1: ad a9 0e  -         lda X
0db4: 85 48     -         sta Y
0db6: a9 a1     -         lda #<addr
0db8: 85 43     -         sta X
0dba: a9 0e     -         lda #>addr
0dbc: 85 44     -         sta X+1
0dbe: a9 02     -         lda #data_size
0dc0: 85 49     -         sta VAR_C
0dc2: 20 9b 08  -         jsr SPLICE
0dc5: ce a9 0e  -         dec candidates_length						//dec array length
0dc8: a6 3f     -         ldx TEMPX									//restore x
0dca: 4c 92 0d  -         jmp cont									//return to loop
0dcd: a5 71     - CANDIDATE_FROM_STACK:lda X
0dcf: 38        -         sec
0dd0: e9 02     -         sbc #C
0dd2: 85 71     -         sta X
0dd4: b0 02     -         bcs out+2
0dd6: c6 72     - out:    dec X+1
0dd8: a0 00     -         ldy #0									//x
0dda: b1 71     -         lda (STKPTR1),y
0ddc: 99 a1 0e  -         sta candidates_vectors,y
0ddf: c8        -         iny										//y
0de0: b1 71     -         lda (STKPTR1),y
0de2: 99 a1 0e  -         sta candidates_vectors,y
0de5: a5 71     -         lda X
0de7: 38        -         sec
0de8: e9 02     -         sbc #C
0dea: 85 71     -         sta X
0dec: b0 02     -         bcs out+2
0dee: c6 72     - out:    dec X+1
0df0: a0 00     -         ldy #0									//x
0df2: b1 71     -         lda (STKPTR1),y
0df4: 99 99 0e  -         sta candidates,y
0df7: c8        -         iny										//y
0df8: b1 71     -         lda (STKPTR1),y
0dfa: 99 99 0e  -         sta candidates,y
0dfd: a9 01     -         lda #01
0dff: 8d a9 0e  -         sta candidates_length
0e02: 60        - out:    rts
0e03: 20 78 09  - MAZE:   jsr MAZE_FILL
0e06: 20 93 09  - outer,P_LOOP:jsr MAZE_DOT
0e09: 20 ef 09  -         jsr POINTERS_FROM_START
0e0c: 20 37 0a  -         jsr FILTER_IF_OUT
0e0f: 20 a0 0a  -         jsr FILTER_IF_DOT
0e12: 20 c8 0b  -         jsr FILTER_IF_CLOSE_PRIMARY
0e15: 20 a8 0c  -         jsr FILTER_SIDE_PROXIMIY
0e18: ad a9 0e  -         lda candidates_length						//check how many we have
0e1b: c9 00     -         cmp #00										//if zero break;
0e1d: f0 41     -         beq S_LOOP									//goto stack loop
0e1f: c9 02     -         cmp #02										//if it is two or more
0e21: b0 05     -         bcs then									//go to else/then
0e23: a9 00     -         lda #0										//otherwise, index->0 in A									
0e25: 4c 3c 0e  -         jmp skip_else
0e28: ad a9 0e  - then:   lda candidates_length
0e2b: aa        -         tax
0e2c: ca        -         dex
0e2d: 86 02     -         stx ZP0
0e2f: a5 02     -         lda X	
0e31: 85 fd     -         sta ZP3
0e33: a9 00     -         lda #0
0e35: 85 fe     -         sta ZP4
0e37: 20 38 09  -         jsr rnd_X
0e3a: a5 14     -         lda WINT
0e3c: 85 02     - skip_else:sta ZP0										//store index in ZP0	
0e3e: 0a        -         asl 										//datasize=2	
0e3f: a8        -         tay											//offset in y
0e40: a9 99     -         lda #<addr
0e42: 85 43     -         sta X
0e44: a9 0e     -         lda #>addr
0e46: 85 44     -         sta X+1
0e48: b1 43     -         lda (BV1),y
0e4a: 8d 91 0e  -         sta maze_start
0e4d: c8        -         iny
0e4e: b1 43     -         lda (BV1),y
0e50: 8d 92 0e  -         sta maze_start+1
0e53: ad a9 0e  -         lda candidates_length
0e56: c9 02     -         cmp #02										//if there are 2 or more, selected has not been discarded yet
0e58: 90 03     -         bcc repeat_P								//no, repeat loop
0e5a: 20 57 0b  -         jsr PUSH_REST_ON_STACK													
0e5d: 4c 06 0e  - repeat_P:jmp P_LOOP
0e60: a5 71     - S_LOOP: lda STKPTR1
0e62: c9 00     -         cmp #<STACK
0e64: d0 09     -         bne cont
0e66: a5 72     -         lda STKPTR2
0e68: c9 c0     -         cmp #>STACK
0e6a: d0 03     -         bne cont
0e6c: 4c 8e 0e  -         jmp quit									//stack pointer == STACK, stack is empty
0e6f: 20 cd 0d  - cont:   jsr CANDIDATE_FROM_STACK					//take on grid an its direction from stack
0e72: 20 c8 0b  -         jsr FILTER_IF_CLOSE_PRIMARY					//recheck if they are still 'safe'
0e75: 20 a8 0c  -         jsr FILTER_SIDE_PROXIMIY					//in terms of proximity
0e78: ad a9 0e  -         lda candidates_length						//check if it is still ok
0e7b: c9 00     -         cmp #00										//if zero break; 
0e7d: f0 e1     -         beq S_LOOP									//no, find another
0e7f: ad 99 0e  -         lda candidates								//set it to maze_start
0e82: 8d 91 0e  -         sta maze_start
0e85: ad 9a 0e  -         lda candidates+1
0e88: 8d 92 0e  -         sta maze_start+1
0e8b: 4c 06 0e  -         jmp P_LOOP									//make next branch
0e8e: 60        - quit:   rts

[MAZE Memory]
0e8f: 40 00     - MAZE_memory,maze_memory_alloc:.word $0040 	//screen by default, safe
0e91: 00 00     - maze_start:.word 0
0e93: 00 00     - grid_pointer:.word 0
0e95: 00 00     - direction_pointer:.word 0
0e97: 00 00     - test_pointer:.word 0
0e99: 00 00     - candidates:.fill 2,0
0e9b: 00 00     -         .fill 2,0
0e9d: 00 00     -         .fill 2,0
0e9f: 00 00     -         .fill 2,0
0ea1: 00 00     - candidates_vectors:.fill 2,0
0ea3: 00 00     -         .fill 2,0
0ea5: 00 00     -         .fill 2,0
0ea7: 00 00     -         .fill 2,0
0ea9: 00        - candidates_length:.byte 0
0eaa: 00 00     - proximity_vectors:.fill 2,0
0eac: 00 00     -         .fill 2,0
0eae: 00 00     -         .fill 2,0
0eb0: 00 00     -         .fill 2,0
0eb2: 2e 20     - debug:  .text ". "
0eb4: 00        -         brk

[Subroutines]
0eb5: ad ea 0e  - subs,irqcode:lda modeflag
0eb8: f0 03     -         beq mode1
0eba: 4c d2 0e  -         jmp mode2
0ebd: a9 01     - mode1:  lda #$01
0ebf: 8d ea 0e  -         sta modeflag
0ec2: a9 06     -         lda #BLUE
0ec4: 8d 20 d0  -         sta BORDER
0ec7: a9 32     -         lda #startRaster
0ec9: 8d 12 d0  -         sta RASTER_COUNTER
0ecc: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
0ecf: 4c 31 ea  -         jmp IRQOUT
0ed2: a9 00     - mode2:  lda #$00
0ed4: 8d ea 0e  -         sta modeflag
0ed7: a9 0e     -         lda #LIGHTBLUE
0ed9: 8d 20 d0  -         sta BORDER
0edc: a9 fa     -         lda #endRaster
0ede: 8d 12 d0  -         sta RASTER_COUNTER
0ee1: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
0ee4: 68        -         pla
0ee5: a8        -         tay
0ee6: 68        -         pla
0ee7: aa        -         tax
0ee8: 68        -         pla
0ee9: 40        -         rti

[Data]
0eea: 00        - text,data,modeflag:.byte 0
0eeb: 00        - startX: .byte 0
0eec: 00        - startY: .byte 0
