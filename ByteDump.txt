******************************* Segment: Default *******************************
[Header]
0801: 0c 08     -         .word bend
0803: 0d 00     -         .byte $0d, $00				//;line number
0805: 9e        -         .byte $9E					//;SYS
0806: 20        -         .byte $20					//;space
0807: 32 30 36 34                                      -         .byte $32,$30,$36,$34		//;start 2064
080b: 00        -         .byte $00					//;end of line
080c: 00 00     - bend:   .byte $00, $00				//;end of basic program

[Main]
0810: 20 2a 09  - setup:  jsr COPY_CHAR_ROM_TO_RAM
0813: 20 21 15  -         jsr set_bricks
0816: a9 0f     -         lda	#color
0818: a0 00     -         ldy #0
081a: 99 00 d8  - fill:   sta COLOR_RAM,y
081d: 99 00 d9  -         sta COLOR_RAM + 256,y
0820: 99 00 da  -         sta COLOR_RAM + 512,y
0823: 99 00 db  -         sta COLOR_RAM + 768,y
0826: c8        -         iny
0827: d0 f1     -         bne fill
0829: a9 00     -         lda #BLACK
082b: 8d 21 d0  -         sta BACKGROUND
082e: 78        - interrupt:sei								//set interrupt
082f: a9 7f     -         lda #$7f
0831: 8d 0d dc  -         sta CIA_ICR
0834: 8d 0d dd  -         sta CIA2_ICR
0837: ad 0d dc  -         lda CIA_ICR
083a: ad 0d dd  -         lda CIA2_ICR
083d: ad 1a d0  -         lda INTERRUPT_MASK_REGISTER	
0840: 09 01     -         ora #$01
0842: 8d 1a d0  -         sta INTERRUPT_MASK_REGISTER
0845: ad 11 d0  -         lda CONTROL_REGISTER1
0848: 29 7f     -         and #$7f
084a: 8d 11 d0  -         sta CONTROL_REGISTER1
084d: a9 32     -         lda #startRaster
084f: 8d 12 d0  -         sta RASTER_COUNTER
0852: a9 ec     -         lda #<address
0854: 8d 14 03  -         sta IRQVEC
0857: a9 14     -         lda #>address
0859: 8d 15 03  -         sta	IRQVEC+1
085c: 58        -         cli
085d: d8        - begin:  cld
085e: a9 02     - init:   lda #B
0860: 8d 85 14  -         sta bias
0863: a9 00     -         lda #00
0865: 8d 86 14  -         sta bias_counter
0868: a9 00     -         lda #<addr
086a: 8d 62 14  -         sta X
086d: a9 04     -         lda #>addr
086f: 8d 63 14  -         sta X+1
0872: a9 00     -         lda #<addr
0874: 85 71     -         sta X
0876: a9 c0     -         lda #>addr
0878: 85 72     -         sta X+1
087a: a9 00     -         lda #<addr
087c: 85 5c     -         sta X
087e: a9 c6     -         lda #>addr
0880: 85 5d     -         sta X+1
0882: a9 00     -         lda #<addr
0884: 85 5e     -         sta X
0886: a9 c7     -         lda #>addr
0888: 85 5f     -         sta X+1
088a: a9 00     -         lda #00
088c: 8d 89 14  -         sta DE_counter
088f: 8d 8a 14  -         sta REM_DE_counter
0892: 20 db 09  -         jsr MAZE_FILL
0895: a9 0f     -         lda	#color
0897: a0 00     -         ldy #0
0899: 99 00 d8  - fill:   sta COLOR_RAM,y
089c: 99 00 d9  -         sta COLOR_RAM + 256,y
089f: 99 00 da  -         sta COLOR_RAM + 512,y
08a2: 99 00 db  -         sta COLOR_RAM + 768,y
08a5: c8        -         iny
08a6: d0 f1     -         bne fill
08a8: 20 52 0a  -         jsr ROOMS
08ab: 20 9e 11  -         jsr SET_START
08ae: 20 97 13  -         jsr MAZE
08b1: 20 c7 11  -         jsr CONNECT_ROOMS
08b4: ad 89 14  - while:  lda DE_counter				// while DE > 0, repeat:
08b7: c9 00     -         cmp #00
08b9: f0 09     -         beq done
08bb: 20 a9 0f  -         jsr CONNECT_DEAD_ENDS
08be: 20 3b 0f  -         jsr POLISH_DEAD_END
08c1: 4c b4 08  -         jmp while
08c4: a5 c5     - done,end,key:lda LSTX		//get character in A
08c6: c9 40     -         cmp #64			//no key
08c8: f0 fa     -         beq key
08ca: 4c 5e 08  -         jmp init
08cd: 60        -         rts

[Imports]
08ce: c6 48     - imports,SPLICE:dec VAR_B								//array length - 1, last index
08d0: a4 47     -         ldy VAR_A								//index
08d2: c4 48     - loop:   cpy VAR_B								//stop if index
08d4: 10 35     -         bpl out 								//equal or greater than last index
08d6: a2 00     -         ldx #0									//number of properties (data_size), start from 0
08d8: c8        - each:   iny		
08d9: 84 40     -         sty TEMPY
08db: a5 49     -         lda	VAR_C 								//data size
08dd: 20 0c 09  -         jsr MUL_Y_A
08e0: 84 02     -         sty ZP0
08e2: 8a        -         txa
08e3: 18        -         clc
08e4: 65 02     -         adc ZP0
08e6: a8        -         tay
08e7: b1 43     -         lda (BV1),y
08e9: 85 41     -         sta TEMPA1
08eb: a4 40     -         ldy TEMPY
08ed: 88        -         dey
08ee: 84 40     -         sty TEMPY
08f0: a5 49     -         lda	VAR_C 								//data size
08f2: 20 0c 09  -         jsr MUL_Y_A
08f5: 84 02     -         sty ZP0
08f7: 8a        -         txa
08f8: 18        -         clc
08f9: 65 02     -         adc ZP0
08fb: a8        -         tay
08fc: a5 41     -         lda TEMPA1
08fe: 91 43     -         sta (BV1),y
0900: a4 40     -         ldy TEMPY
0902: e8        -         inx
0903: e4 49     -         cpx VAR_C								//all props? less than VAR_C ?
0905: 90 d1     -         bcc each
0907: c8        -         iny
0908: 4c d2 08  -         jmp loop
090b: 60        - out:    rts
090c: c0 00     - MUL_Y_A,multiply:cpy #00
090e: f0 18     -         beq end
0910: 88        -         dey
0911: 8c 1e 09  -         sty mod+1
0914: 4a        -         lsr
0915: 85 02     -         sta ZP0
0917: a9 00     -         lda #00
0919: a0 08     -         ldy #$08
091b: 90 02     - loop:   bcc skip
091d: 69 00     - mod:    adc #0
091f: 6a        - skip:   ror
0920: 66 02     -         ror ZP0
0922: 88        -         dey
0923: d0 f6     -         bne loop
0925: a4 02     -         ldy ZP0
0927: 60        -         rts
0928: 98        - end:    tya
0929: 60        -         rts
092a: 78        - COPY_CHAR_ROM_TO_RAM:sei
092b: a5 01     -         lda $01			//make ROM visible
092d: 29 fb     -         and #$FB
092f: 85 01     -         sta $01 
0931: a9 00     -         lda #00
0933: 85 5f     -         sta $5f			//block start
0935: 85 5a     -         sta $5a			//block end
0937: 85 58     -         sta $58			//destination end
0939: a0 d0     -         ldy #$d0
093b: 84 60     -         sty $60			//block start
093d: a0 e0     -         ldy #$e0		
093f: 84 5b     -         sty $5b			//block end
0941: a0 40     - ram:    ldy #$40
0943: 84 59     -         sty $59			//destination end
0945: 20 bf a3  -         jsr MOVE_BYTES
0948: a5 01     -         lda $01			//hide rom
094a: 09 04     -         ora #$04
094c: 85 01     -         sta $01
094e: 58        -         cli
094f: ad 18 d0  -         lda VMCSB
0952: 29 f0     -         and #%11110000
0954: 09 0c     -         ora #%00001100	//$3000
0956: 8d 18 d0  -         sta VMCSB
0959: 60        -         rts

[SYSTEM_data]
095a: e6 fd     - SYS_data,rnd_XY:inc ZP3
095c: d0 02     -         bne skip1
095e: e6 fe     -         inc ZP4
0960: a5 fd     - skip1:  lda ZP3
0962: 38        -         sec
0963: e5 fb     -         sbc ZP1
0965: 85 fd     -         sta ZP3
0967: a5 fe     -         lda ZP4
0969: e5 fc     -         sbc ZP2
096b: 85 fe     -         sta ZP4			
096d: a4 fd     - toFloat:ldy ZP3
096f: a5 fe     -         lda ZP4
0971: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
0974: a2 c6     -         ldx #<flt
0976: a0 09     -         ldy #>flt
0978: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
097b: a9 00     -         lda #$00					//RND(0)
097d: 20 9a e0  -         jsr RND						//$E09A
0980: a9 c6     -         lda #<flt
0982: a0 09     -         ldy #>flt
0984: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
0987: 20 cc bc  -         jsr FAINT					//to integer
098a: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
098d: a5 65     -         lda $65						//FAC mantissa lo
098f: 18        -         clc
0990: 65 fb     -         adc ZP1						//add number to start	
0992: 85 14     -         sta WINT
0994: a5 64     -         lda $64						//FAC mantissa hi
0996: 65 fc     -         adc ZP2
0998: 85 15     -         sta WINT+1
099a: 60        - over:   rts			
099b: e6 fd     - rnd_X:  inc ZP3
099d: d0 02     -         bne toFloat
099f: e6 fe     -         inc ZP4	
09a1: a4 fd     - toFloat:ldy ZP3
09a3: a5 fe     -         lda ZP4
09a5: 20 91 b3  -         jsr GIVAYF 					//A(h),Y(L) - FAC
09a8: a2 c6     -         ldx #<flt
09aa: a0 09     -         ldy #>flt
09ac: 20 d4 bb  -         jsr MOVMF					//store FAC to flt		
09af: a9 00     -         lda #$00					//get actual RND(0)
09b1: 20 9a e0  -         jsr RND						//$E09A
09b4: a9 c6     -         lda #<flt
09b6: a0 09     -         ldy #>flt
09b8: 20 28 ba  -         jsr FMULT					//Multiplies a number from RAM (A,y) and FAC	
09bb: 20 cc bc  -         jsr FAINT					//to integer
09be: 20 bf b1  -         jsr AYINT					//fac to signed int HI $64 LO $65
09c1: a5 65     -         lda $65						//FAC mantissa lo
09c3: 85 14     -         sta WINT					
09c5: 60        -         rts			

[Data RND]
09c6: 00 00 00 00 00                                   - dataRND,flt:.byte 0,0,0,0,0

[Grid_Constants]
09cb: 00 ff     - Grid_Constants,BASIC_DIRS,UP:.byte 	0, -1
09cd: 00 01     - DOWN:   .byte 	0, 1
09cf: ff 00     - LEFT:   .byte	-1, 0
09d1: 01 00     - RIGHT:  .byte 	1,0
09d3: ff ff     - PROX_TEMPLATE:.byte 	-1, -1
09d5: 01 01     -         .byte 	1, 1
09d7: ff ff     -         .byte 	-1, -1
09d9: 01 01     -         .byte 	1, 1
09db: ad 62 14  - MAZE_FILL:lda X
09de: 85 fb     -         sta Y
09e0: ad 63 14  -         lda X + 1
09e3: 85 fc     -         sta Y + 1
09e5: a9 00     -         lda	#WALL
09e7: a2 04     -         ldx #4
09e9: a0 00     - block:  ldy #0
09eb: 91 fb     - fill:   sta (ZP1),y
09ed: c8        -         iny
09ee: d0 fb     -         bne fill
09f0: e6 fc     -         inc ZP2
09f2: ca        -         dex
09f3: d0 f4     -         bne block
09f5: 60        -         rts
09f6: ad 62 14  - MAZE_DOT:lda X
09f9: 85 fb     -         sta Y
09fb: ad 63 14  -         lda X + 1
09fe: 85 fc     -         sta Y + 1
0a00: a9 00     -         lda #0
0a02: 85 fe     -         sta ZP4				
0a04: ad 65 14  -         lda grid+1		
0a07: 85 fd     -         sta ZP3
0a09: a0 03     -         ldy #03
0a0b: 06 fd     - mul8:   asl X
0a0d: 26 fe     -         rol X+1	
0a0f: 88        -         dey
0a10: d0 f9     -         bne mul8
0a12: a5 fb     -         lda X
0a14: 18        -         clc
0a15: 65 fd     -         adc Y
0a17: 85 fb     -         sta X
0a19: 90 02     -         bcc skip
0a1b: e6 fc     -         inc X+1
0a1d: a5 fc     - skip:   lda X+1
0a1f: 18        -         clc
0a20: 65 fe     -         adc Y+1
0a22: 85 fc     -         sta X+1	
0a24: a0 02     -         ldy #02	
0a26: 06 fd     - mul32:  asl X
0a28: 26 fe     -         rol X+1	
0a2a: 88        -         dey
0a2b: d0 f9     -         bne mul32
0a2d: a5 fb     -         lda X
0a2f: 18        -         clc
0a30: 65 fd     -         adc Y
0a32: 85 fb     -         sta X
0a34: 90 02     -         bcc skip
0a36: e6 fc     -         inc X+1
0a38: a5 fc     - skip:   lda X+1
0a3a: 18        -         clc
0a3b: 65 fe     -         adc Y+1
0a3d: 85 fc     -         sta X+1	
0a3f: a5 fb     -         lda X
0a41: 18        -         clc
0a42: 6d 64 14  -         adc y	
0a45: 85 fb     -         sta X
0a47: 90 02     -         bcc out+2
0a49: e6 fc     - out:    inc X+1
0a4b: a5 53     -         lda TEMPY2
0a4d: a0 00     -         ldy #0
0a4f: 91 fb     -         sta (ZP1),y
0a51: 60        -         rts
0a52: 20 65 10  - ROOMS:  jsr MAKE_ROOMS
0a55: 20 59 0a  -         jsr PAINT_ROOMS
0a58: 60        -         rts
0a59: a2 00     - PAINT_ROOMS:ldx #00
0a5b: 86 3f     - each:   stx TEMPX				//each room
0a5d: 8a        -         txa
0a5e: 0a        -         asl
0a5f: 0a        -         asl
0a60: a8        -         tay
0a61: b9 8b 14  -         lda rooms,y				//get top left x of room
0a64: 85 4e     -         sta BV9
0a66: c8        -         iny
0a67: b9 8b 14  -         lda rooms,y				//get top left y of room
0a6a: 85 4f     -         sta BV10
0a6c: c8        -         iny
0a6d: b9 8b 14  -         lda rooms,y 			//w
0a70: 85 02     -         sta ZP0
0a72: c8        -         iny
0a73: b9 8b 14  -         lda rooms,y 			//h
0a76: 85 52     -         sta BV0
0a78: a2 00     -         ldx #0
0a7a: a0 00     - cont_w: ldy #0
0a7c: 86 41     - cont_h: stx TEMPA1
0a7e: a5 4e     -         lda BV9
0a80: 18        -         clc
0a81: 65 41     -         adc TEMPA1
0a83: 8d 64 14  -         sta maze_start
0a86: 84 41     -         sty TEMPA1
0a88: a5 4f     -         lda BV10
0a8a: 18        -         clc
0a8b: 65 41     -         adc TEMPA1
0a8d: 8d 65 14  -         sta maze_start+1
0a90: 84 40     -         sty TEMPY
0a92: a9 20     -         lda #value
0a94: 85 53     -         sta TEMPY2
0a96: 20 f6 09  -         jsr MAZE_DOT
0a99: a4 40     -         ldy TEMPY
0a9b: c8        -         iny
0a9c: c4 52     -         cpy BV0
0a9e: d0 dc     -         bne cont_h
0aa0: e8        -         inx
0aa1: e4 02     -         cpx ZP0
0aa3: d0 d5     -         bne cont_w
0aa5: a6 3f     -         ldx TEMPX
0aa7: e8        -         inx
0aa8: e0 04     -         cpx #ROOM_NUMBER
0aaa: d0 af     -         bne each
0aac: 60        - out:    rts
0aad: a2 03     - POINTERS_FROM_START:ldx #03
0aaf: 8a        - add:    txa
0ab0: 0a        -         asl
0ab1: a8        -         tay		
0ab2: 18        -         clc
0ab3: ad 64 14  -         lda maze_start
0ab6: 79 cb 09  -         adc BASIC_DIRS,y
0ab9: 99 6c 14  -         sta candidates,y
0abc: c8        -         iny
0abd: 18        -         clc
0abe: ad 65 14  -         lda maze_start+1
0ac1: 79 cb 09  -         adc BASIC_DIRS,y
0ac4: 99 6c 14  -         sta candidates,y
0ac7: ca        -         dex
0ac8: 10 e5     -         bpl add
0aca: a2 03     -         ldx #03
0acc: 8a        - copy:   txa
0acd: 0a        -         asl
0ace: a8        -         tay	
0acf: b9 cb 09  -         lda BASIC_DIRS,y
0ad2: 99 74 14  -         sta candidates_vectors,y
0ad5: c8        -         iny
0ad6: b9 cb 09  -         lda BASIC_DIRS,y
0ad9: 99 74 14  -         sta candidates_vectors,y
0adc: ca        -         dex
0add: 10 ed     -         bpl copy
0adf: a9 04     -         lda #04
0ae1: 8d 7c 14  -         sta candidates_length
0ae4: 60        -         rts
0ae5: ad 7c 14  - FILTER_IF_OUT:lda candidates_length
0ae8: c9 01     -         cmp #1
0aea: b0 01     -         bcs start
0aec: 60        -         rts
0aed: ae 7c 14  - start:  ldx candidates_length				//number of grids yet to check
0af0: ca        -         dex
0af1: 8a        - each:   txa
0af2: 0a        -         asl
0af3: a8        -         tay
0af4: 18        -         clc
0af5: b9 6c 14  -         lda candidates,y
0af8: c9 27     -         cmp #MAX_X+1
0afa: b0 18     -         bcs shift
0afc: c9 01     -         cmp #MIN_X
0afe: 90 14     -         bcc shift
0b00: c8        -         iny
0b01: 18        -         clc
0b02: b9 6c 14  -         lda candidates,y
0b05: c9 18     -         cmp #MAX_Y+1
0b07: b0 0b     -         bcs shift
0b09: c9 01     -         cmp #MIN_Y
0b0b: 90 07     -         bcc shift
0b0d: ca        - cont:   dex
0b0e: 30 03     -         bmi out
0b10: 4c f1 0a  -         jmp each
0b13: 60        - out:    rts
0b14: 86 3f     - shift:  stx TEMPX									//save x							
0b16: 86 47     -         stx VAR_A									//set index to VAR_A
0b18: ad 7c 14  -         lda X
0b1b: 85 48     -         sta Y
0b1d: a9 6c     -         lda #<addr
0b1f: 85 43     -         sta X
0b21: a9 14     -         lda #>addr
0b23: 85 44     -         sta X+1
0b25: a9 02     -         lda #data_size
0b27: 85 49     -         sta VAR_C
0b29: 20 ce 08  -         jsr SPLICE
0b2c: ad 7c 14  -         lda X
0b2f: 85 48     -         sta Y
0b31: a9 74     -         lda #<addr
0b33: 85 43     -         sta X
0b35: a9 14     -         lda #>addr
0b37: 85 44     -         sta X+1
0b39: a9 02     -         lda #data_size
0b3b: 85 49     -         sta VAR_C
0b3d: 20 ce 08  -         jsr SPLICE
0b40: ce 7c 14  -         dec candidates_length						//dec array length
0b43: a6 3f     -         ldx TEMPX									//restore x
0b45: 4c 0d 0b  -         jmp cont									//return to loop
0b48: ad 7c 14  - FILTER_IF_DOT:lda candidates_length
0b4b: c9 01     -         cmp #1
0b4d: b0 01     -         bcs start
0b4f: 60        -         rts
0b50: ae 7c 14  - start:  ldx candidates_length						//number of grids yet to check
0b53: ca        -         dex
0b54: 8a        - each:   txa
0b55: 0a        -         asl
0b56: a8        -         tay
0b57: b9 6c 14  -         lda candidates,y
0b5a: 8d 66 14  -         sta grid_pointer
0b5d: c8        -         iny
0b5e: b9 6c 14  -         lda candidates,y
0b61: 8d 67 14  -         sta grid_pointer+1
0b64: ad 62 14  -         lda X
0b67: 85 fb     -         sta Y
0b69: ad 63 14  -         lda X + 1
0b6c: 85 fc     -         sta Y + 1
0b6e: a9 00     -         lda #0
0b70: 85 fe     -         sta ZP4				
0b72: ad 67 14  -         lda grid+1		
0b75: 85 fd     -         sta ZP3
0b77: a0 03     -         ldy #03
0b79: 06 fd     - mul8:   asl X
0b7b: 26 fe     -         rol X+1	
0b7d: 88        -         dey
0b7e: d0 f9     -         bne mul8
0b80: a5 fb     -         lda X
0b82: 18        -         clc
0b83: 65 fd     -         adc Y
0b85: 85 fb     -         sta X
0b87: 90 02     -         bcc skip
0b89: e6 fc     -         inc X+1
0b8b: a5 fc     - skip:   lda X+1
0b8d: 18        -         clc
0b8e: 65 fe     -         adc Y+1
0b90: 85 fc     -         sta X+1	
0b92: a0 02     -         ldy #02	
0b94: 06 fd     - mul32:  asl X
0b96: 26 fe     -         rol X+1	
0b98: 88        -         dey
0b99: d0 f9     -         bne mul32
0b9b: a5 fb     -         lda X
0b9d: 18        -         clc
0b9e: 65 fd     -         adc Y
0ba0: 85 fb     -         sta X
0ba2: 90 02     -         bcc skip
0ba4: e6 fc     -         inc X+1
0ba6: a5 fc     - skip:   lda X+1
0ba8: 18        -         clc
0ba9: 65 fe     -         adc Y+1
0bab: 85 fc     -         sta X+1	
0bad: a5 fb     -         lda X
0baf: 18        -         clc
0bb0: 6d 66 14  -         adc y	
0bb3: 85 fb     -         sta X
0bb5: 90 02     -         bcc out+2
0bb7: e6 fc     - out:    inc X+1
0bb9: a0 00     -         ldy #0
0bbb: b1 fb     -         lda (ZP1),y
0bbd: c5 52     -         cmp BV0										//value to compare in BV0
0bbf: f0 04     -         beq shift
0bc1: ca        - cont:   dex
0bc2: 10 90     -         bpl each
0bc4: 60        - out:    rts
0bc5: 86 3f     - shift:  stx TEMPX									//save x
0bc7: 86 47     -         stx VAR_A									//set index to VAR_A
0bc9: ad 7c 14  -         lda X
0bcc: 85 48     -         sta Y
0bce: a9 6c     -         lda #<addr
0bd0: 85 43     -         sta X
0bd2: a9 14     -         lda #>addr
0bd4: 85 44     -         sta X+1
0bd6: a9 02     -         lda #data_size
0bd8: 85 49     -         sta VAR_C
0bda: 20 ce 08  -         jsr SPLICE
0bdd: ad 7c 14  -         lda X
0be0: 85 48     -         sta Y
0be2: a9 74     -         lda #<addr
0be4: 85 43     -         sta X
0be6: a9 14     -         lda #>addr
0be8: 85 44     -         sta X+1
0bea: a9 02     -         lda #data_size
0bec: 85 49     -         sta VAR_C
0bee: 20 ce 08  -         jsr SPLICE
0bf1: ce 7c 14  -         dec candidates_length						//dec array length
0bf4: a6 3f     -         ldx TEMPX									//restore x
0bf6: 4c c1 0b  -         jmp cont									//return to loop
0bf9: a5 02     - PUSH_REST_ON_STACK:lda ZP0										//index was stored in ZP0
0bfb: 85 47     -         sta VAR_A									//set index to VAR_A
0bfd: ad 7c 14  -         lda X
0c00: 85 48     -         sta Y
0c02: a9 6c     -         lda #<addr
0c04: 85 43     -         sta X
0c06: a9 14     -         lda #>addr
0c08: 85 44     -         sta X+1
0c0a: a9 02     -         lda #data_size
0c0c: 85 49     -         sta VAR_C
0c0e: 20 ce 08  -         jsr SPLICE
0c11: ad 7c 14  -         lda X
0c14: 85 48     -         sta Y
0c16: a9 74     -         lda #<addr
0c18: 85 43     -         sta X
0c1a: a9 14     -         lda #>addr
0c1c: 85 44     -         sta X+1
0c1e: a9 02     -         lda #data_size
0c20: 85 49     -         sta VAR_C
0c22: 20 ce 08  -         jsr SPLICE
0c25: ce 7c 14  -         dec candidates_length						//dec array length
0c28: a2 00     -         ldx #0
0c2a: a0 00     - each:   ldy #0
0c2c: 86 3f     -         stx TEMPX									//save x
0c2e: 8a        -         txa											//x = x *2	
0c2f: 0a        -         asl 
0c30: aa        -         tax									
0c31: bd 6c 14  -         lda candidates,x							//x
0c34: 91 71     -         sta (STKPTR1),y
0c36: c8        -         iny
0c37: e8        -         inx
0c38: bd 6c 14  -         lda candidates,x							//y
0c3b: 91 71     -         sta (STKPTR1),y
0c3d: a5 71     -         lda X
0c3f: 18        -         clc
0c40: 69 02     -         adc #C
0c42: 85 71     -         sta X
0c44: 90 02     -         bcc out+2
0c46: e6 72     - out:    inc X+1
0c48: 88        -         dey
0c49: ca        -         dex
0c4a: bd 74 14  -         lda candidates_vectors,x					//x
0c4d: 91 71     -         sta (STKPTR1),y
0c4f: c8        -         iny
0c50: e8        -         inx
0c51: bd 74 14  -         lda candidates_vectors,x					//y
0c54: 91 71     -         sta (STKPTR1),y
0c56: a5 71     -         lda X
0c58: 18        -         clc
0c59: 69 02     -         adc #C
0c5b: 85 71     -         sta X
0c5d: 90 02     -         bcc out+2
0c5f: e6 72     - out:    inc X+1
0c61: a6 3f     -         ldx TEMPX									//restore x
0c63: e8        -         inx
0c64: ec 7c 14  -         cpx candidates_length
0c67: d0 c1     -         bne each
0c69: 60        - out:    rts		
0c6a: ad 7c 14  - FILTER_IF_NEXT_PRIMARY:lda candidates_length
0c6d: c9 01     -         cmp #1
0c6f: b0 01     -         bcs start										//cont if 1 or more
0c71: 60        -         rts												//else exit, if no candidates
0c72: ae 7c 14  - start:  ldx candidates_length							//number of grids yet to check
0c75: ca        -         dex												//to zero offset
0c76: 8a        - each:   txa
0c77: 0a        -         asl												//double, because datasize is 2
0c78: a8        -         tay												//offset in y (zero based x * datasize)
0c79: b9 6c 14  -         lda candidates,y
0c7c: 8d 66 14  -         sta grid_pointer
0c7f: b9 74 14  -         lda candidates_vectors,y
0c82: 8d 68 14  -         sta direction_pointer
0c85: c8        -         iny
0c86: b9 6c 14  -         lda candidates,y
0c89: 8d 67 14  -         sta grid_pointer+1
0c8c: b9 74 14  -         lda candidates_vectors,y
0c8f: 8d 69 14  -         sta direction_pointer+1
0c92: 18        -         clc
0c93: ad 66 14  -         lda grid_pointer
0c96: 6d 68 14  -         adc direction_pointer
0c99: 8d 6a 14  -         sta test_pointer
0c9c: 18        -         clc
0c9d: ad 67 14  -         lda grid_pointer+1
0ca0: 6d 69 14  -         adc direction_pointer+1
0ca3: 8d 6b 14  -         sta test_pointer+1
0ca6: ad 62 14  -         lda X
0ca9: 85 fb     -         sta Y
0cab: ad 63 14  -         lda X + 1
0cae: 85 fc     -         sta Y + 1
0cb0: a9 00     -         lda #0
0cb2: 85 fe     -         sta ZP4				
0cb4: ad 6b 14  -         lda grid+1		
0cb7: 85 fd     -         sta ZP3
0cb9: a0 03     -         ldy #03
0cbb: 06 fd     - mul8:   asl X
0cbd: 26 fe     -         rol X+1	
0cbf: 88        -         dey
0cc0: d0 f9     -         bne mul8
0cc2: a5 fb     -         lda X
0cc4: 18        -         clc
0cc5: 65 fd     -         adc Y
0cc7: 85 fb     -         sta X
0cc9: 90 02     -         bcc skip
0ccb: e6 fc     -         inc X+1
0ccd: a5 fc     - skip:   lda X+1
0ccf: 18        -         clc
0cd0: 65 fe     -         adc Y+1
0cd2: 85 fc     -         sta X+1	
0cd4: a0 02     -         ldy #02	
0cd6: 06 fd     - mul32:  asl X
0cd8: 26 fe     -         rol X+1	
0cda: 88        -         dey
0cdb: d0 f9     -         bne mul32
0cdd: a5 fb     -         lda X
0cdf: 18        -         clc
0ce0: 65 fd     -         adc Y
0ce2: 85 fb     -         sta X
0ce4: 90 02     -         bcc skip
0ce6: e6 fc     -         inc X+1
0ce8: a5 fc     - skip:   lda X+1
0cea: 18        -         clc
0ceb: 65 fe     -         adc Y+1
0ced: 85 fc     -         sta X+1	
0cef: a5 fb     -         lda X
0cf1: 18        -         clc
0cf2: 6d 6a 14  -         adc y	
0cf5: 85 fb     -         sta X
0cf7: 90 02     -         bcc out+2
0cf9: e6 fc     - out:    inc X+1
0cfb: a0 00     -         ldy #0
0cfd: b1 fb     -         lda (ZP1),y
0cff: c5 52     -         cmp BV0										//BV0 holds the value to filter out
0d01: f0 07     -         beq shift									//yes
0d03: ca        - cont:   dex
0d04: 30 03     -         bmi out										//less than zero, stop
0d06: 4c 76 0c  -         jmp each									//loop back, branch too far
0d09: 60        - out:    rts
0d0a: 86 3f     - shift:  stx TEMPX									//save x
0d0c: 86 47     -         stx VAR_A									//set index to VAR_A
0d0e: ad 7c 14  -         lda X
0d11: 85 48     -         sta Y
0d13: a9 6c     -         lda #<addr
0d15: 85 43     -         sta X
0d17: a9 14     -         lda #>addr
0d19: 85 44     -         sta X+1
0d1b: a9 02     -         lda #data_size
0d1d: 85 49     -         sta VAR_C
0d1f: 20 ce 08  -         jsr SPLICE
0d22: ad 7c 14  -         lda X
0d25: 85 48     -         sta Y
0d27: a9 74     -         lda #<addr
0d29: 85 43     -         sta X
0d2b: a9 14     -         lda #>addr
0d2d: 85 44     -         sta X+1
0d2f: a9 02     -         lda #data_size
0d31: 85 49     -         sta VAR_C
0d33: 20 ce 08  -         jsr SPLICE
0d36: ce 7c 14  -         dec candidates_length						//dec array length
0d39: a6 3f     -         ldx TEMPX									//restore x
0d3b: 4c 03 0d  -         jmp cont									//return to loop
0d3e: ad 7c 14  - FILTER_N_CONNECTIONS:lda candidates_length
0d41: c9 01     -         cmp #1
0d43: b0 01     -         bcs start										//cont if 1 or more
0d45: 60        -         rts												//else exit, if no candidates
0d46: ae 7c 14  - start:  ldx candidates_length							//number of grids yet to check
0d49: ca        -         dex												//to zero offset	
0d4a: 86 3f     - each:   stx TEMPX										// save x 
0d4c: 8a        -         txa
0d4d: 0a        -         asl												//double, because datasize is 2
0d4e: a8        -         tay												//offset in y (zero based x * datasize)
0d4f: b9 6c 14  -         lda candidates,y
0d52: 8d 66 14  -         sta grid_pointer
0d55: c8        -         iny
0d56: b9 6c 14  -         lda candidates,y
0d59: 8d 67 14  -         sta grid_pointer+1
0d5c: ad 66 14  -         lda bridge
0d5f: 85 50     -         sta BV7
0d61: ad 67 14  -         lda bridge+1
0d64: 85 51     -         sta BV8
0d66: a9 00     -         lda #0
0d68: 85 4a     -         sta VAR_D
0d6a: 20 20 13  -         jsr CHECK_CONNECTION
0d6d: a6 3f     -         ldx TEMPX										//restore x
0d6f: a5 4a     -         lda VAR_D										//value to compare is in BV0
0d71: c5 52     -         cmp BV0
0d73: d0 07     -         bne shift										//not equal, shift											
0d75: ca        - cont:   dex
0d76: 30 03     -         bmi out											//less than zero, stop
0d78: 4c 4a 0d  -         jmp each										//loop back, branch too far
0d7b: 60        - out:    rts
0d7c: 86 3f     - shift:  stx TEMPX									//save x
0d7e: 86 47     -         stx VAR_A									//set index to VAR_A
0d80: ad 7c 14  -         lda X
0d83: 85 48     -         sta Y
0d85: a9 6c     -         lda #<addr
0d87: 85 43     -         sta X
0d89: a9 14     -         lda #>addr
0d8b: 85 44     -         sta X+1
0d8d: a9 02     -         lda #data_size
0d8f: 85 49     -         sta VAR_C
0d91: 20 ce 08  -         jsr SPLICE
0d94: ad 7c 14  -         lda X
0d97: 85 48     -         sta Y
0d99: a9 74     -         lda #<addr
0d9b: 85 43     -         sta X
0d9d: a9 14     -         lda #>addr
0d9f: 85 44     -         sta X+1
0da1: a9 02     -         lda #data_size
0da3: 85 49     -         sta VAR_C
0da5: 20 ce 08  -         jsr SPLICE
0da8: ce 7c 14  -         dec candidates_length						//dec array length
0dab: a6 3f     -         ldx TEMPX									//restore x
0dad: 4c 75 0d  -         jmp cont									//return to loop
0db0: ad 7c 14  - FILTER_SIDE_PROXIMIY:lda candidates_length
0db3: c9 01     -         cmp #1
0db5: b0 01     -         bcs start										//cont if 1 or more
0db7: 60        -         rts												//else exit, if no candidates
0db8: ae 7c 14  - start:  ldx candidates_length							//number of grids yet to check
0dbb: ca        -         dex												//to zero offset
0dbc: 8a        - each:   txa
0dbd: 0a        -         asl												//double, because datasize is 2
0dbe: a8        -         tay												//offset in y (zero based x * datasize)
0dbf: b9 6c 14  -         lda candidates, y
0dc2: 8d 66 14  -         sta grid_pointer
0dc5: b9 74 14  -         lda candidates_vectors,y
0dc8: 8d 68 14  -         sta direction_pointer
0dcb: c8        -         iny
0dcc: b9 6c 14  -         lda candidates, y
0dcf: 8d 67 14  -         sta grid_pointer+1
0dd2: b9 74 14  -         lda candidates_vectors,y
0dd5: 8d 69 14  -         sta direction_pointer+1
0dd8: a9 d3     -         lda #<addr
0dda: 85 50     -         sta X
0ddc: a9 09     -         lda #>addr
0dde: 85 51     -         sta X+1
0de0: a9 7d     -         lda #<addr
0de2: 85 4e     -         sta X
0de4: a9 14     -         lda #>addr
0de6: 85 4f     -         sta X+1
0de8: a0 08     -         ldy #length											
0dea: 88        -         dey
0deb: b1 50     - copy:   lda (BV7),y
0ded: 91 4e     -         sta (BV9),y
0def: 88        -         dey
0df0: 10 f9     -         bpl copy
0df2: a0 01     -         ldy #01											//y?
0df4: b9 68 14  -         lda direction_pointer,y
0df7: d0 01     -         bne ok											//if not zero, than this is right dimension
0df9: 88        -         dey												//not y, but x
0dfa: b9 68 14  - ok:     lda direction_pointer,y							//index of dimension now in y register
0dfd: 99 7d 14  -         sta proximity_vectors,y							//set sequence 1,1,0,0 on the right dimension, datasize=2
0e00: c8        -         iny
0e01: c8        -         iny
0e02: 99 7d 14  -         sta proximity_vectors,y	
0e05: c8        -         iny
0e06: c8        -         iny
0e07: a9 00     -         lda #0
0e09: 99 7d 14  -         sta proximity_vectors,y	
0e0c: c8        -         iny
0e0d: c8        -         iny
0e0e: 99 7d 14  -         sta proximity_vectors,y							//proximity vectors ready
0e11: a0 00     -         ldy #00
0e13: ad 66 14  - repeat: lda grid_pointer
0e16: 18        -         clc
0e17: 79 7d 14  -         adc proximity_vectors,y
0e1a: 8d 6a 14  -         sta test_pointer
0e1d: c8        -         iny
0e1e: ad 67 14  -         lda grid_pointer+1
0e21: 18        -         clc
0e22: 79 7d 14  -         adc proximity_vectors,y
0e25: 8d 6b 14  -         sta test_pointer+1								//next grid now in test_pointer
0e28: 84 40     -         sty TEMPY										//save y
0e2a: ad 62 14  -         lda X
0e2d: 85 fb     -         sta Y
0e2f: ad 63 14  -         lda X + 1
0e32: 85 fc     -         sta Y + 1
0e34: a9 00     -         lda #0
0e36: 85 fe     -         sta ZP4				
0e38: ad 6b 14  -         lda grid+1		
0e3b: 85 fd     -         sta ZP3
0e3d: a0 03     -         ldy #03
0e3f: 06 fd     - mul8:   asl X
0e41: 26 fe     -         rol X+1	
0e43: 88        -         dey
0e44: d0 f9     -         bne mul8
0e46: a5 fb     -         lda X
0e48: 18        -         clc
0e49: 65 fd     -         adc Y
0e4b: 85 fb     -         sta X
0e4d: 90 02     -         bcc skip
0e4f: e6 fc     -         inc X+1
0e51: a5 fc     - skip:   lda X+1
0e53: 18        -         clc
0e54: 65 fe     -         adc Y+1
0e56: 85 fc     -         sta X+1	
0e58: a0 02     -         ldy #02	
0e5a: 06 fd     - mul32:  asl X
0e5c: 26 fe     -         rol X+1	
0e5e: 88        -         dey
0e5f: d0 f9     -         bne mul32
0e61: a5 fb     -         lda X
0e63: 18        -         clc
0e64: 65 fd     -         adc Y
0e66: 85 fb     -         sta X
0e68: 90 02     -         bcc skip
0e6a: e6 fc     -         inc X+1
0e6c: a5 fc     - skip:   lda X+1
0e6e: 18        -         clc
0e6f: 65 fe     -         adc Y+1
0e71: 85 fc     -         sta X+1	
0e73: a5 fb     -         lda X
0e75: 18        -         clc
0e76: 6d 6a 14  -         adc y	
0e79: 85 fb     -         sta X
0e7b: 90 02     -         bcc out+2
0e7d: e6 fc     - out:    inc X+1
0e7f: a0 00     -         ldy #0
0e81: b1 fb     -         lda (ZP1),y
0e83: c9 20     -         cmp #DOT										//is dot? (empty)
0e85: f0 0e     -         beq shift										//yes, shift on x
0e87: a4 40     -         ldy TEMPY										//restore y
0e89: c8        -         iny
0e8a: c0 08     -         cpy #08
0e8c: d0 85     -         bne repeat
0e8e: ca        - cont:   dex
0e8f: 30 03     -         bmi out										//less than zero, stop
0e91: 4c bc 0d  -         jmp each									//loop back, branch too far
0e94: 60        - out:    rts
0e95: 86 3f     - shift:  stx TEMPX									//save x
0e97: 86 47     -         stx VAR_A									//set index to VAR_A
0e99: ad 7c 14  -         lda X
0e9c: 85 48     -         sta Y
0e9e: a9 6c     -         lda #<addr
0ea0: 85 43     -         sta X
0ea2: a9 14     -         lda #>addr
0ea4: 85 44     -         sta X+1
0ea6: a9 02     -         lda #data_size
0ea8: 85 49     -         sta VAR_C
0eaa: 20 ce 08  -         jsr SPLICE
0ead: ad 7c 14  -         lda X
0eb0: 85 48     -         sta Y
0eb2: a9 74     -         lda #<addr
0eb4: 85 43     -         sta X
0eb6: a9 14     -         lda #>addr
0eb8: 85 44     -         sta X+1
0eba: a9 02     -         lda #data_size
0ebc: 85 49     -         sta VAR_C
0ebe: 20 ce 08  -         jsr SPLICE
0ec1: ce 7c 14  -         dec candidates_length						//dec array length
0ec4: a6 3f     -         ldx TEMPX									//restore x
0ec6: 4c 8e 0e  -         jmp cont									//return to loop
0ec9: a5 71     - CANDIDATE_FROM_STACK:lda X
0ecb: 38        -         sec
0ecc: e9 02     -         sbc #C
0ece: 85 71     -         sta X
0ed0: b0 02     -         bcs out+2
0ed2: c6 72     - out:    dec X+1
0ed4: a0 00     -         ldy #0									//x
0ed6: b1 71     -         lda (STKPTR1),y
0ed8: 99 74 14  -         sta candidates_vectors,y
0edb: c8        -         iny										//y
0edc: b1 71     -         lda (STKPTR1),y
0ede: 99 74 14  -         sta candidates_vectors,y
0ee1: a5 71     -         lda X
0ee3: 38        -         sec
0ee4: e9 02     -         sbc #C
0ee6: 85 71     -         sta X
0ee8: b0 02     -         bcs out+2
0eea: c6 72     - out:    dec X+1
0eec: a0 00     -         ldy #0									//x
0eee: b1 71     -         lda (STKPTR1),y
0ef0: 99 6c 14  -         sta candidates,y
0ef3: c8        -         iny										//y
0ef4: b1 71     -         lda (STKPTR1),y
0ef6: 99 6c 14  -         sta candidates,y
0ef9: a9 01     -         lda #01
0efb: 8d 7c 14  -         sta candidates_length
0efe: 60        - out:    rts
0eff: ae 7c 14  - CHECK_BIAS:ldx candidates_length
0f02: ca        -         dex
0f03: 8a        - each:   txa
0f04: 0a        -         asl 								// length to offset in
0f05: a8        -         tay									// y
0f06: b9 74 14  -         lda candidates_vectors,y			// x dim
0f09: cd 87 14  -         cmp bias_direction
0f0c: d0 09     -         bne not 							//not same
0f0e: c8        -         iny
0f0f: b9 74 14  -         lda	candidates_vectors,y			// y dim	
0f12: cd 88 14  -         cmp bias_direction+1				//the same
0f15: f0 06     -         beq found
0f17: ca        - not:    dex
0f18: 10 e9     -         bpl each
0f1a: a9 ff     -         lda #-1								//not found: -1
0f1c: 60        -         rts
0f1d: 8a        - found:  txa									//index in acc
0f1e: 60        -         rts
0f1f: a0 00     - STORE_DEAD_END:ldy #0
0f21: ad 64 14  -         lda maze_start			//x
0f24: 91 5c     -         sta (STKPTR3),y
0f26: c8        -         iny
0f27: ad 65 14  -         lda maze_start+1		//y
0f2a: 91 5c     -         sta (STKPTR3),y
0f2c: ee 89 14  -         inc DE_counter			//assumption always less than 255
0f2f: a5 5c     -         lda X
0f31: 18        -         clc
0f32: 69 02     -         adc #C
0f34: 85 5c     -         sta X
0f36: 90 02     -         bcc out+2
0f38: e6 5d     - out:    inc X+1
0f3a: 60        - out:    rts
0f3b: a9 00     - POLISH_DEAD_END:lda #<addr
0f3d: 85 5e     -         sta X
0f3f: a9 c7     -         lda #>addr
0f41: 85 5f     -         sta X+1
0f43: a9 00     -         lda #<addr
0f45: 85 5c     -         sta X
0f47: a9 c6     -         lda #>addr
0f49: 85 5d     -         sta X+1
0f4b: a9 00     -         lda #0	
0f4d: 8d 89 14  -         sta DE_counter							//reset counter
0f50: ae 8a 14  -         ldx REM_DE_counter						//starting from last DE towards 0th
0f53: e0 00     -         cpx #0
0f55: d0 01     -         bne start
0f57: 60        -         rts
0f58: ca        - start:  dex
0f59: 86 0a     - each_DE:stx GLOBAL_X
0f5b: 8a        -         txa
0f5c: 0a        -         asl
0f5d: a8        -         tay
0f5e: b1 5e     -         lda (STKPTR5),y
0f60: 8d 64 14  -         sta maze_start
0f63: c8        -         iny
0f64: b1 5e     -         lda (STKPTR5),y
0f66: 8d 65 14  -         sta maze_start+1						//selected Dead End --> in maze_start
0f69: 20 ad 0a  -         jsr POINTERS_FROM_START
0f6c: a9 00     -         lda #value
0f6e: 85 52     -         sta BV0
0f70: 20 48 0b  -         jsr FILTER_IF_DOT
0f73: a0 00     -         ldy #0
0f75: ad 64 14  -         lda	maze_start
0f78: 18        -         clc
0f79: 79 74 14  -         adc candidates_vectors,y
0f7c: 8d 66 14  -         sta grid_pointer
0f7f: c8        -         iny
0f80: ad 65 14  -         lda maze_start+1
0f83: 18        -         clc
0f84: 79 74 14  -         adc candidates_vectors,y
0f87: 8d 67 14  -         sta grid_pointer+1						//next possible DE in grid_pointer
0f8a: a9 00     -         lda #value
0f8c: 85 53     -         sta TEMPY2
0f8e: 20 f6 09  -         jsr MAZE_DOT
0f91: ad 66 14  -         lda X
0f94: 8d 64 14  -         sta Y
0f97: ad 67 14  -         lda X + 1
0f9a: 8d 65 14  -         sta Y + 1
0f9d: 20 1f 0f  -         jsr STORE_DEAD_END						//STORE_DEAD_END expects it
0fa0: a6 0a     - end_loop:ldx GLOBAL_X
0fa2: ca        -         dex
0fa3: 30 03     -         bmi out
0fa5: 4c 59 0f  -         jmp each_DE
0fa8: 60        - out:    rts
0fa9: a9 00     - CONNECT_DEAD_ENDS:lda #<addr
0fab: 85 5c     -         sta X
0fad: a9 c6     -         lda #>addr
0faf: 85 5d     -         sta X+1
0fb1: a9 00     -         lda #0
0fb3: 8d 8a 14  -         sta REM_DE_counter
0fb6: ae 89 14  -         ldx DE_counter							//starting from last DE towards 0th
0fb9: e0 00     -         cpx #0
0fbb: d0 01     -         bne start
0fbd: 60        -         rts
0fbe: ca        - start:  dex
0fbf: 86 0a     - each_DE:stx GLOBAL_X
0fc1: 8a        -         txa
0fc2: 0a        -         asl 									//datasize=2
0fc3: a8        -         tay										//offset in y
0fc4: b1 5c     -         lda (STKPTR3),y
0fc6: 8d 64 14  -         sta maze_start
0fc9: c8        -         iny
0fca: b1 5c     -         lda (STKPTR3),y
0fcc: 8d 65 14  -         sta maze_start+1						//selected Dead End --> in maze_start
0fcf: ad 64 14  -         lda bridge
0fd2: 85 50     -         sta BV7
0fd4: ad 65 14  -         lda bridge+1
0fd7: 85 51     -         sta BV8
0fd9: a9 00     -         lda #0
0fdb: 85 4a     -         sta VAR_D
0fdd: 20 20 13  -         jsr CHECK_CONNECTION
0fe0: a5 4a     -         lda VAR_D								//check if still DE (only one grid is dot, rest are wall)
0fe2: c9 01     -         cmp #01									//--> number of connections is exactly 1
0fe4: f0 03     -         beq still_DE							//yes
0fe6: 4c 5c 10  -         jmp end_loop							//no, check next
0fe9: 20 ad 0a  - still_DE:jsr POINTERS_FROM_START					//candidates for bridges in candidates
0fec: 20 e5 0a  -         jsr FILTER_IF_OUT
0fef: a9 20     -         lda #value
0ff1: 85 52     -         sta BV0
0ff3: 20 48 0b  -         jsr FILTER_IF_DOT
0ff6: a9 00     -         lda #test
0ff8: 85 52     -         sta BV0
0ffa: 20 6a 0c  -         jsr FILTER_IF_NEXT_PRIMARY
0ffd: a9 02     -         lda #N
0fff: 85 52     -         sta BV0
1001: 20 3e 0d  -         jsr FILTER_N_CONNECTIONS
1004: ad 7c 14  -         lda candidates_length						//check how many we have
1007: c9 00     -         cmp #00										//if zero break;
1009: d0 1e     -         bne more									//more than 0
100b: a0 00     -         ldy #0										//store into remainder stack
100d: ad 64 14  -         lda maze_start								//x
1010: 91 5e     -         sta (STKPTR5),y
1012: c8        -         iny
1013: ad 65 14  -         lda maze_start+1							//y
1016: 91 5e     -         sta (STKPTR5),y
1018: ee 8a 14  -         inc REM_DE_counter							//assumption always less than 255
101b: a5 5e     -         lda X
101d: 18        -         clc
101e: 69 02     -         adc #C
1020: 85 5e     -         sta X
1022: 90 02     -         bcc out+2
1024: e6 5f     - out:    inc X+1
1026: 4c 5c 10  -         jmp end_loop								//nothing to paint
1029: c9 02     - more:   cmp #02										//if it is two or more
102b: b0 05     -         bcs select_random							//go to else/select_random
102d: a9 00     -         lda #0										//otherwise, index->0 in A									
102f: 4c 46 10  -         jmp skip_else
1032: ad 7c 14  - select_random:lda candidates_length						//random index (, candidates length-1)
1035: aa        -         tax
1036: ca        -         dex
1037: 86 02     -         stx ZP0
1039: a5 02     -         lda X	
103b: 85 fd     -         sta ZP3
103d: a9 00     -         lda #0
103f: 85 fe     -         sta ZP4
1041: 20 9b 09  -         jsr rnd_X
1044: a5 14     -         lda WINT
1046: 0a        - skip_else:asl 										//datasize=2	
1047: a8        -         tay											//offset in y
1048: b9 6c 14  -         lda candidates,y	
104b: 8d 64 14  -         sta maze_start
104e: c8        -         iny
104f: b9 6c 14  -         lda candidates,y
1052: 8d 65 14  -         sta maze_start+1							
1055: a9 20     -         lda #value
1057: 85 53     -         sta TEMPY2
1059: 20 f6 09  -         jsr MAZE_DOT
105c: a6 0a     - end_loop:ldx GLOBAL_X
105e: ca        -         dex
105f: 30 03     -         bmi out
1061: 4c bf 0f  -         jmp each_DE
1064: 60        - out:    rts
1065: a2 00     - MAKE_ROOMS:ldx #0
1067: 86 3f     - each:   stx TEMPX
1069: 8a        -         txa
106a: 0a        -         asl
106b: 0a        -         asl
106c: a8        -         tay					//datasize 4 from x to y
106d: a9 00     -         lda #0
106f: 85 fc     -         sta ZP2
1071: 85 fe     -         sta ZP4
1073: b9 9b 14  -         lda room_def,y
1076: 85 fb     -         sta ZP1				//x from
1078: b9 9c 14  -         lda room_def+1,y
107b: 85 fd     -         sta ZP3				//x to
107d: 84 40     -         sty TEMPY
107f: 20 5a 09  -         jsr rnd_XY
1082: a5 14     -         lda WINT
1084: a4 40     -         ldy TEMPY
1086: 99 8b 14  -         sta rooms,y			//top x random(from, to)
1089: a9 00     -         lda #0
108b: 85 fc     -         sta ZP2
108d: 85 fe     -         sta ZP4
108f: b9 9d 14  -         lda room_def+2,y
1092: 85 fb     -         sta ZP1				//y from
1094: b9 9e 14  -         lda room_def+3,y
1097: 85 fd     -         sta ZP3				//y to
1099: 84 40     -         sty TEMPY
109b: 20 5a 09  -         jsr rnd_XY
109e: a5 14     -         lda WINT
10a0: a4 40     -         ldy TEMPY
10a2: c8        -         iny
10a3: 99 8b 14  -         sta rooms,y			//top y random(from, to)
10a6: a9 00     -         lda #0
10a8: 85 fc     -         sta ZP2
10aa: 85 fe     -         sta ZP4
10ac: a9 03     -         lda #MIN_W
10ae: 85 fb     -         sta ZP1
10b0: a9 04     -         lda #MAX_W
10b2: 85 fd     -         sta ZP3
10b4: 84 40     -         sty TEMPY
10b6: 20 5a 09  -         jsr rnd_XY
10b9: a5 14     -         lda WINT
10bb: a4 40     -         ldy TEMPY
10bd: c8        -         iny	
10be: 99 8b 14  -         sta rooms,y			//w
10c1: a9 00     -         lda #0
10c3: 85 fc     -         sta ZP2
10c5: 85 fe     -         sta ZP4
10c7: a9 03     -         lda #MIN_W
10c9: 85 fb     -         sta ZP1
10cb: a9 04     -         lda #MAX_W
10cd: 85 fd     -         sta ZP3
10cf: 84 40     -         sty TEMPY
10d1: 20 5a 09  -         jsr rnd_XY
10d4: a5 14     -         lda WINT
10d6: a4 40     -         ldy TEMPY
10d8: c8        -         iny	
10d9: 99 8b 14  -         sta rooms,y			//h
10dc: a6 3f     -         ldx TEMPX
10de: e8        -         inx
10df: e0 04     -         cpx #ROOM_NUMBER
10e1: d0 84     -         bne each
10e3: 60        - out:    rts
10e4: a2 00     - GET_EXIT_CANDIDATES,init:ldx #0
10e6: 8e eb 14  -         stx exit_candidates_length		//reset ...
10e9: 0a        -         asl 							//room index in A
10ea: 0a        -         asl 							//* 4 and to y	
10eb: a8        -         tay								//y offset of room index, datzasize = 4
10ec: b9 8c 14  -         lda rooms+1,y					//y
10ef: 85 40     -         sta TEMPY
10f1: c6 40     -         dec TEMPY						//y-1
10f3: 18        -         clc
10f4: 79 8e 14  -         adc rooms+3,y
10f7: 85 53     -         sta TEMPY2						//y+h
10f9: b9 8d 14  -         lda rooms+2,y
10fc: 85 02     -         sta ZP0	
10fe: b9 8b 14  -         lda rooms,y
1101: 85 52     -         sta BV0							//x + i
1103: 84 47     -         sty VAR_A						//save offset of room index
1105: a2 00     -         ldx #00
1107: ad eb 14  - width_loop:lda	exit_candidates_length
110a: 0a        -         asl 							//datasize of candidates = 2
110b: a8        -         tay								//exit_candidates offset in y
110c: a5 52     -         lda	BV0							//x+i
110e: 99 ab 14  -         sta exit_candidates,y	
1111: a9 00     -         lda #0
1113: 99 cb 14  -         sta exit_candidate_dirs,y
1116: c8        -         iny
1117: a5 40     -         lda TEMPY						//y-1
1119: 99 ab 14  -         sta exit_candidates,y
111c: a9 ff     -         lda #-1							
111e: 99 cb 14  -         sta exit_candidate_dirs,y
1121: c8        -         iny
1122: ee eb 14  -         inc exit_candidates_length
1125: a5 52     -         lda	BV0							//x+i
1127: 99 ab 14  -         sta exit_candidates,y	
112a: a9 00     -         lda #0
112c: 99 cb 14  -         sta exit_candidate_dirs,y
112f: c8        -         iny
1130: a5 53     -         lda TEMPY2						//y+h
1132: 99 ab 14  -         sta	exit_candidates,y	
1135: a9 01     -         lda #1
1137: 99 cb 14  -         sta exit_candidate_dirs,y
113a: ee eb 14  -         inc exit_candidates_length		
113d: e6 52     -         inc BV0							//i++
113f: e8        -         inx
1140: e4 02     -         cpx ZP0
1142: d0 c3     -         bne width_loop
1144: a4 47     -         ldy VAR_A						//restore offset of room index
1146: b9 8b 14  -         lda rooms,y						//x
1149: 85 3f     -         sta TEMPX
114b: c6 3f     -         dec TEMPX						//x-1
114d: 18        -         clc
114e: 79 8d 14  -         adc rooms+2,y
1151: 85 4d     -         sta TEMPX2						//x+w
1153: b9 8e 14  -         lda rooms+3,y					//h
1156: 85 02     -         sta ZP0
1158: b9 8c 14  -         lda rooms+1,y
115b: 85 52     -         sta BV0							//y + i
115d: a2 00     -         ldx #00
115f: ad eb 14  - height_loop:lda	exit_candidates_length
1162: 0a        -         asl 							//datasize of candidates = 2
1163: a8        -         tay								//exit_candidates offset in y
1164: a5 3f     -         lda TEMPX						//x-1
1166: 99 ab 14  -         sta exit_candidates,y
1169: a9 ff     -         lda #-1
116b: 99 cb 14  -         sta exit_candidate_dirs,y
116e: c8        -         iny
116f: a5 52     -         lda BV0							//y+i
1171: 99 ab 14  -         sta exit_candidates,y
1174: a9 00     -         lda #0
1176: 99 cb 14  -         sta exit_candidate_dirs,y
1179: c8        -         iny
117a: ee eb 14  -         inc exit_candidates_length
117d: a5 4d     -         lda TEMPX2						//x+w
117f: 99 ab 14  -         sta exit_candidates,y
1182: a9 01     -         lda #01
1184: 99 cb 14  -         sta exit_candidate_dirs,y
1187: c8        -         iny
1188: a5 52     -         lda BV0							//y+i
118a: 99 ab 14  -         sta exit_candidates,y
118d: a9 00     -         lda #0
118f: 99 cb 14  -         sta exit_candidate_dirs,y
1192: c8        -         iny
1193: ee eb 14  -         inc exit_candidates_length
1196: e6 52     -         inc BV0							//i++
1198: e8        -         inx
1199: e4 02     -         cpx ZP0
119b: d0 c2     -         bne height_loop				
119d: 60        - out:    rts
119e: a9 00     - SET_START:lda #0							//room index in A
11a0: 20 e4 10  -         jsr GET_EXIT_CANDIDATES
11a3: ad eb 14  -         lda exit_candidates_length
11a6: 85 02     -         sta ZP0
11a8: c6 02     -         dec ZP0
11aa: a5 02     -         lda X	
11ac: 85 fd     -         sta ZP3
11ae: a9 00     -         lda #0
11b0: 85 fe     -         sta ZP4
11b2: 20 9b 09  -         jsr rnd_X
11b5: a5 14     -         lda WINT
11b7: 0a        -         asl 
11b8: a8        -         tay
11b9: b9 ab 14  -         lda exit_candidates,y
11bc: 8d 64 14  -         sta maze_start
11bf: c8        -         iny
11c0: b9 ab 14  -         lda exit_candidates,y
11c3: 8d 65 14  -         sta maze_start+1
11c6: 60        - out:    rts
11c7: a2 01     - CONNECT_ROOMS:ldx #01												//start with index 1, 0 should be already connected
11c9: 86 0a     - each:   stx GLOBAL_X											//save x
11cb: 8a        -         txa													//GET_EXIT_CANDIDATES expects room index in A
11cc: 20 e4 10  -         jsr GET_EXIT_CANDIDATES								//trashes TEMPX
11cf: ac eb 14  - get_one:ldy exit_candidates_length
11d2: 88        -         dey
11d3: 84 02     -         sty ZP0
11d5: a5 02     -         lda X	
11d7: 85 fd     -         sta ZP3
11d9: a9 00     -         lda #0
11db: 85 fe     -         sta ZP4
11dd: 20 9b 09  -         jsr rnd_X
11e0: a5 14     -         lda WINT											//random index
11e2: 0a        -         asl 
11e3: a8        -         tay													//offset in y
11e4: b9 ab 14  -         lda exit_candidates,y
11e7: 8d 66 14  -         sta grid_pointer									//bridge
11ea: b9 cb 14  -         lda exit_candidate_dirs,y
11ed: 8d 68 14  -         sta direction_pointer								//dir to test
11f0: c8        -         iny
11f1: b9 ab 14  -         lda exit_candidates,y
11f4: 8d 67 14  -         sta grid_pointer+1
11f7: b9 cb 14  -         lda exit_candidate_dirs,y
11fa: 8d 69 14  -         sta direction_pointer+1							
11fd: ad 66 14  -         lda grid_pointer
1200: 18        -         clc
1201: 6d 68 14  -         adc direction_pointer
1204: 8d 6a 14  -         sta test_pointer
1207: ad 67 14  -         lda grid_pointer+1
120a: 18        -         clc
120b: 6d 69 14  -         adc direction_pointer+1
120e: 8d 6b 14  -         sta test_pointer+1
1211: ad 62 14  -         lda X
1214: 85 fb     -         sta Y
1216: ad 63 14  -         lda X + 1
1219: 85 fc     -         sta Y + 1
121b: a9 00     -         lda #0
121d: 85 fe     -         sta ZP4				
121f: ad 6b 14  -         lda grid+1		
1222: 85 fd     -         sta ZP3
1224: a0 03     -         ldy #03
1226: 06 fd     - mul8:   asl X
1228: 26 fe     -         rol X+1	
122a: 88        -         dey
122b: d0 f9     -         bne mul8
122d: a5 fb     -         lda X
122f: 18        -         clc
1230: 65 fd     -         adc Y
1232: 85 fb     -         sta X
1234: 90 02     -         bcc skip
1236: e6 fc     -         inc X+1
1238: a5 fc     - skip:   lda X+1
123a: 18        -         clc
123b: 65 fe     -         adc Y+1
123d: 85 fc     -         sta X+1	
123f: a0 02     -         ldy #02	
1241: 06 fd     - mul32:  asl X
1243: 26 fe     -         rol X+1	
1245: 88        -         dey
1246: d0 f9     -         bne mul32
1248: a5 fb     -         lda X
124a: 18        -         clc
124b: 65 fd     -         adc Y
124d: 85 fb     -         sta X
124f: 90 02     -         bcc skip
1251: e6 fc     -         inc X+1
1253: a5 fc     - skip:   lda X+1
1255: 18        -         clc
1256: 65 fe     -         adc Y+1
1258: 85 fc     -         sta X+1	
125a: a5 fb     -         lda X
125c: 18        -         clc
125d: 6d 6a 14  -         adc y	
1260: 85 fb     -         sta X
1262: 90 02     -         bcc out+2
1264: e6 fc     - out:    inc X+1
1266: a0 00     -         ldy #0
1268: b1 fb     -         lda (ZP1),y
126a: c9 20     -         cmp #DOT											//is it dot
126c: f0 32     -         beq check_connections								//yes, check connections
126e: a5 14     -         lda WINT											//random index was still in WINT
1270: 85 47     -         sta VAR_A											//store index in VAR_A
1272: ad eb 14  -         lda X
1275: 85 48     -         sta Y
1277: a9 ab     -         lda #<addr
1279: 85 43     -         sta X
127b: a9 14     -         lda #>addr
127d: 85 44     -         sta X+1
127f: a9 02     -         lda #data_size
1281: 85 49     -         sta VAR_C
1283: 20 ce 08  -         jsr SPLICE
1286: ad eb 14  -         lda X
1289: 85 48     -         sta Y
128b: a9 cb     -         lda #<addr
128d: 85 43     -         sta X
128f: a9 14     -         lda #>addr
1291: 85 44     -         sta X+1
1293: a9 02     -         lda #data_size
1295: 85 49     -         sta VAR_C
1297: 20 ce 08  -         jsr SPLICE
129a: ce eb 14  -         dec exit_candidates_length							//exit_candidates_length--
129d: 4c cf 11  -         jmp get_one											//try another
12a0: ad 66 14  - check_connections:lda bridge
12a3: 85 50     -         sta BV7
12a5: ad 67 14  -         lda bridge+1
12a8: 85 51     -         sta BV8
12aa: a9 00     -         lda #0
12ac: 85 4a     -         sta VAR_D
12ae: 20 20 13  -         jsr CHECK_CONNECTION
12b1: a5 4a     -         lda VAR_D
12b3: c9 02     -         cmp #02												//exactly two directions required for bridge
12b5: f0 03     -         beq yes												//yes, paint
12b7: 4c cf 11  -         jmp get_one											//not ok, get another
12ba: ad 62 14  - yes:    lda X
12bd: 85 fb     -         sta Y
12bf: ad 63 14  -         lda X + 1
12c2: 85 fc     -         sta Y + 1
12c4: a9 00     -         lda #0
12c6: 85 fe     -         sta ZP4				
12c8: ad 67 14  -         lda grid+1		
12cb: 85 fd     -         sta ZP3
12cd: a0 03     -         ldy #03
12cf: 06 fd     - mul8:   asl X
12d1: 26 fe     -         rol X+1	
12d3: 88        -         dey
12d4: d0 f9     -         bne mul8
12d6: a5 fb     -         lda X
12d8: 18        -         clc
12d9: 65 fd     -         adc Y
12db: 85 fb     -         sta X
12dd: 90 02     -         bcc skip
12df: e6 fc     -         inc X+1
12e1: a5 fc     - skip:   lda X+1
12e3: 18        -         clc
12e4: 65 fe     -         adc Y+1
12e6: 85 fc     -         sta X+1	
12e8: a0 02     -         ldy #02	
12ea: 06 fd     - mul32:  asl X
12ec: 26 fe     -         rol X+1	
12ee: 88        -         dey
12ef: d0 f9     -         bne mul32
12f1: a5 fb     -         lda X
12f3: 18        -         clc
12f4: 65 fd     -         adc Y
12f6: 85 fb     -         sta X
12f8: 90 02     -         bcc skip
12fa: e6 fc     -         inc X+1
12fc: a5 fc     - skip:   lda X+1
12fe: 18        -         clc
12ff: 65 fe     -         adc Y+1
1301: 85 fc     -         sta X+1	
1303: a5 fb     -         lda X
1305: 18        -         clc
1306: 6d 66 14  -         adc y	
1309: 85 fb     -         sta X
130b: 90 02     -         bcc out+2
130d: e6 fc     - out:    inc X+1
130f: a9 20     -         lda #DOT
1311: a0 00     -         ldy #0
1313: 91 fb     -         sta (ZP1),y
1315: a6 0a     -         ldx GLOBAL_X										//restore x
1317: e8        -         inx													//next room
1318: e0 04     -         cpx #ROOM_NUMBER
131a: f0 03     -         beq out
131c: 4c c9 11  -         jmp each
131f: 60        - out:    rts
1320: a2 03     - CHECK_CONNECTION:ldx #03						//iterate over directions
1322: 8a        - each:   txa
1323: 0a        -         asl
1324: a8        -         tay							//offset in y
1325: a5 50     -         lda BV7
1327: 18        -         clc
1328: 79 cb 09  -         adc BASIC_DIRS,y
132b: 85 4e     -         sta BV9						//test.x
132d: c8        -         iny
132e: a5 51     -         lda BV8
1330: 18        -         clc
1331: 79 cb 09  -         adc BASIC_DIRS,y
1334: 85 4f     -         sta BV10					//test.y
1336: ad 62 14  -         lda X
1339: 85 fb     -         sta Y
133b: ad 63 14  -         lda X + 1
133e: 85 fc     -         sta Y + 1
1340: a9 00     -         lda #0
1342: 85 fe     -         sta ZP4				
1344: a5 4f     -         lda grid+1		
1346: 85 fd     -         sta ZP3
1348: a0 03     -         ldy #03
134a: 06 fd     - mul8:   asl X
134c: 26 fe     -         rol X+1	
134e: 88        -         dey
134f: d0 f9     -         bne mul8
1351: a5 fb     -         lda X
1353: 18        -         clc
1354: 65 fd     -         adc Y
1356: 85 fb     -         sta X
1358: 90 02     -         bcc skip
135a: e6 fc     -         inc X+1
135c: a5 fc     - skip:   lda X+1
135e: 18        -         clc
135f: 65 fe     -         adc Y+1
1361: 85 fc     -         sta X+1	
1363: a0 02     -         ldy #02	
1365: 06 fd     - mul32:  asl X
1367: 26 fe     -         rol X+1	
1369: 88        -         dey
136a: d0 f9     -         bne mul32
136c: a5 fb     -         lda X
136e: 18        -         clc
136f: 65 fd     -         adc Y
1371: 85 fb     -         sta X
1373: 90 02     -         bcc skip
1375: e6 fc     -         inc X+1
1377: a5 fc     - skip:   lda X+1
1379: 18        -         clc
137a: 65 fe     -         adc Y+1
137c: 85 fc     -         sta X+1	
137e: a5 fb     -         lda X
1380: 18        -         clc
1381: 65 4e     -         adc y	
1383: 85 fb     -         sta X
1385: 90 02     -         bcc out+2
1387: e6 fc     - out:    inc X+1
1389: a0 00     -         ldy #0
138b: b1 fb     -         lda (ZP1),y
138d: c9 20     -         cmp #DOT
138f: d0 02     -         bne skip
1391: e6 4a     -         inc VAR_D
1393: ca        - skip:   dex
1394: 10 8c     -         bpl each
1396: 60        - out:    rts
1397: 20 1f 0f  - MAZE:   jsr STORE_DEAD_END							//start grid might remain DE!!
139a: a9 20     - outer,P_LOOP:lda #value
139c: 85 53     -         sta TEMPY2
139e: 20 f6 09  -         jsr MAZE_DOT
13a1: 20 ad 0a  -         jsr POINTERS_FROM_START
13a4: 20 e5 0a  -         jsr FILTER_IF_OUT
13a7: a9 20     -         lda #value
13a9: 85 52     -         sta BV0
13ab: 20 48 0b  -         jsr FILTER_IF_DOT
13ae: a9 20     -         lda #test
13b0: 85 52     -         sta BV0
13b2: 20 6a 0c  -         jsr FILTER_IF_NEXT_PRIMARY
13b5: 20 b0 0d  -         jsr FILTER_SIDE_PROXIMIY
13b8: ad 7c 14  -         lda candidates_length						//check how many we have
13bb: c9 00     -         cmp #00										//if zero break;
13bd: d0 06     -         bne more									//more than 0
13bf: 20 1f 0f  -         jsr STORE_DEAD_END							//store dead end
13c2: 4c 2f 14  -         jmp S_LOOP
13c5: c9 02     - more:   cmp #02										//if it is two or more
13c7: b0 05     -         bcs then									//go to else/then
13c9: a9 00     -         lda #0										//otherwise, index->0 in A									
13cb: 4c f5 13  -         jmp skip_else
13ce: ad 86 14  - then:   lda bias_counter
13d1: c9 00     -         cmp #00
13d3: f0 07     -         beq select_random							//use random, not bias
13d5: 20 ff 0e  -         jsr CHECK_BIAS								//index in a, or -1 if not found
13d8: c9 ff     -         cmp #-1
13da: d0 19     -         bne skip_else								//not -1, select this direction
13dc: a9 00     - select_random:lda #0										//reset bias counter when selection is random	
13de: 8d 86 14  -         sta bias_counter
13e1: ad 7c 14  -         lda candidates_length						//random index (, candidates length-1)
13e4: aa        -         tax
13e5: ca        -         dex
13e6: 86 02     -         stx ZP0
13e8: a5 02     -         lda X	
13ea: 85 fd     -         sta ZP3
13ec: a9 00     -         lda #0
13ee: 85 fe     -         sta ZP4
13f0: 20 9b 09  -         jsr rnd_X
13f3: a5 14     -         lda WINT
13f5: 85 02     - skip_else:sta ZP0										//store index in ZP0	
13f7: 0a        -         asl 										//datasize=2	
13f8: a8        -         tay											//offset in y
13f9: b9 6c 14  -         lda candidates,y
13fc: 8d 64 14  -         sta maze_start
13ff: b9 74 14  -         lda candidates_vectors,y
1402: 8d 87 14  -         sta bias_direction
1405: c8        -         iny
1406: b9 6c 14  -         lda candidates,y
1409: 8d 65 14  -         sta maze_start+1
140c: b9 74 14  -         lda candidates_vectors,y
140f: 8d 88 14  -         sta bias_direction+1
1412: ee 86 14  -         inc bias_counter
1415: ad 86 14  -         lda bias_counter
1418: cd 85 14  -         cmp bias
141b: d0 05     -         bne out+3
141d: a9 00     -         lda #00
141f: 8d 86 14  - out:    sta bias_counter
1422: ad 7c 14  -         lda candidates_length
1425: c9 02     -         cmp #02										//if there are 2 or more, selected has not been discarded yet
1427: 90 03     -         bcc repeat_P								//no, repeat loop
1429: 20 f9 0b  -         jsr PUSH_REST_ON_STACK													
142c: 4c 9a 13  - repeat_P:jmp P_LOOP
142f: a5 71     - S_LOOP: lda STKPTR1
1431: c9 00     -         cmp #<STACK
1433: d0 09     -         bne cont
1435: a5 72     -         lda STKPTR2
1437: c9 c0     -         cmp #>STACK
1439: d0 03     -         bne cont
143b: 4c 61 14  -         jmp quit									//stack pointer == STACK, stack is empty
143e: 20 c9 0e  - cont:   jsr CANDIDATE_FROM_STACK					//take on grid an its direction from stack
1441: a9 20     -         lda #test
1443: 85 52     -         sta BV0
1445: 20 6a 0c  -         jsr FILTER_IF_NEXT_PRIMARY
1448: 20 b0 0d  -         jsr FILTER_SIDE_PROXIMIY					//in terms of proximity
144b: ad 7c 14  -         lda candidates_length						//check if it is still ok
144e: c9 00     -         cmp #00										//if zero break; 
1450: f0 dd     -         beq S_LOOP									//no, find another
1452: ad 6c 14  -         lda candidates								//set it to maze_start
1455: 8d 64 14  -         sta maze_start
1458: ad 6d 14  -         lda candidates+1
145b: 8d 65 14  -         sta maze_start+1
145e: 4c 9a 13  -         jmp P_LOOP									//make next branch
1461: 60        - quit:   rts

[MAZE Memory]
1462: 04 00     - MAZE_memory,maze_memory_alloc:.word $0004 					//screen by default
1464: 00 00     - maze_start:.word 0
1466: 00 00     - grid_pointer:.word 0
1468: 00 00     - direction_pointer:.word 0
146a: 00 00     - test_pointer:.word 0
146c: 00 00     - candidates:.fill 2,0
146e: 00 00     -         .fill 2,0
1470: 00 00     -         .fill 2,0
1472: 00 00     -         .fill 2,0
1474: 00 00     - candidates_vectors:.fill 2,0
1476: 00 00     -         .fill 2,0
1478: 00 00     -         .fill 2,0
147a: 00 00     -         .fill 2,0
147c: 00        - candidates_length:.byte 0
147d: 00 00     - proximity_vectors:.fill 2,0
147f: 00 00     -         .fill 2,0
1481: 00 00     -         .fill 2,0
1483: 00 00     -         .fill 2,0
1485: 02        - bias:   .byte 2
1486: 00        - bias_counter:.byte 0
1487: 00 00     - bias_direction:.word 0
1489: 00        - DE_counter:.byte 0
148a: 00        - REM_DE_counter:.byte 0
148b: 00 00 00 00                                      - rooms:  .fill 4,0
148f: 00 00 00 00                                      -         .fill 4,0
1493: 00 00 00 00                                      -         .fill 4,0
1497: 00 00 00 00                                      -         .fill 4,0
149b: 03 0e 03 06                                      - room_def:.byte 3, 14, 3, 6
149f: 17 21 03 06                                      -         .byte 23, 33, 3, 6
14a3: 03 0e 0e 11                                      -         .byte 3, 14, 14, 17
14a7: 17 21 0e 11                                      -         .byte 23, 33, 14, 17
14ab: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - exit_candidates:.fill MAX_W * 4 * 2, 0
14bb: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
14cb: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - exit_candidate_dirs:.fill MAX_W * 4 * 2, 0
14db: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
14eb: 00        - exit_candidates_length:.byte 0

[Subroutines]
14ec: ad 2f 15  - subs,irqcode:lda modeflag
14ef: f0 03     -         beq mode1
14f1: 4c 09 15  -         jmp mode2
14f4: a9 01     - mode1:  lda #$01
14f6: 8d 2f 15  -         sta modeflag
14f9: a9 00     -         lda #BLACK
14fb: 8d 20 d0  -         sta BORDER
14fe: a9 32     -         lda #startRaster
1500: 8d 12 d0  -         sta RASTER_COUNTER
1503: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
1506: 4c 31 ea  -         jmp IRQOUT
1509: a9 00     - mode2:  lda #$00
150b: 8d 2f 15  -         sta modeflag
150e: a9 0f     -         lda #LIGHTGREY
1510: 8d 20 d0  -         sta BORDER
1513: a9 fa     -         lda #endRaster
1515: 8d 12 d0  -         sta RASTER_COUNTER
1518: 0e 19 d0  -         asl INTERRUPT_REQUEST_REGISTER
151b: 68        -         pla
151c: a8        -         tay
151d: 68        -         pla
151e: aa        -         tax
151f: 68        -         pla
1520: 40        -         rti
1521: a2 00     - set_bricks:ldx #00
1523: bd 32 15  - copy:   lda brick_data,x
1526: 9d 00 30  -         sta char_offset,x
1529: e8        -         inx
152a: e0 08     -         cpx #08
152c: d0 f5     -         bne copy
152e: 60        -         rts

[Data]
152f: 00        - text,data,modeflag:.byte 0
1530: 00        - startX: .byte 0
1531: 00        - startY: .byte 0
1532: dd c1 38 bb bb 83 1c dd                          - brick_data:.byte $dd,$c1,$38,$bb,$bb,$83,$1c,$dd
